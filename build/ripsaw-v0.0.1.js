/*! ripsaw v0.0.1 - 2014-12-31 
 *  Copyright: Peter Szerzo, 2014 */

/** @namespace */
var RIPSAW = {

    /**
     * Active drawing mode.
     * @memberof RIPSAW
     * @type {String}
     */
    mode: "mode3",

    /**
     * Stores whether geometry has been modified since the model was initialized.
     * @memberof RIPSAW
     * @type {String}
     */
    isModified: false,

    /**
     * Timestamp at the beginning of a stage.
     * @memberof RIPSAW
     * @type {number}
     */
    time0: new Date().getTime(),

    /**
     * Time elapsed since the stage began.
     * @memberof RIPSAW
     * @type {number}
     */
    time: 0,

    /**
     * Refresh interval [ms].
     * @memberof RIPSAW
     * @type {number}
     */
    refreshInterval: 5,

    /** Controls animations speeds and delays (anim.speed and anim.delay). Values in [ms]. */
    anim: {
        speed: 2000,
        delay: 500
    },

    /**
     * ID of container element.
     * @memberof RIPSAW
     * @type {String}
     */
    containerID: "ripsaw-app",

    /**
     * Font.
     * @memberof RIPSAW
     * @type {String}
     */
    fonts: "Monaco",

    /**
     * Hover tolerance (relative to screen dimensions).
     * @memberof RIPSAW
     * @type {number}
     */
    tolerance: 2e-2,

    /**
     * Number tolerance.
     * @memberof RIPSAW
     * @type {number}
     */
    delta: 1e-7,

    /**
     * Geometry tolerance (identical points).
     * @memberof RIPSAW
     * @type {number}
     */
    delta2: 1e-3,

    /**
     * Default radius of solid circles.
     * @memberof RIPSAW
     * @type {number}
     */
    defaultRadius: 5,

    /**
     * Display width settings.
     * @memberof RIPSAW
     * @type {Object}
     */
    wDisplay: {

        path: 1 / 200,
        navButton: 0.03,
        text: 1 / 80

    },

    /**
     * Real-world product dimensions.
     * @memberof RIPSAW
     * @type {Object}
     */
    rDim: {

        l: 150,
        w: 0,
        d: 3,
        /** how much depth profiles are scaled up for visibility */
        depthScale: 10

    },

    /**
     * Meshing parameters.
     * @memberof RIPSAW
     * @type {Object}
     */
    mesh: {

        /**
         * Spline subdivisions.
         * @memberof RIPSAW.mesh
         * @type {number}
         */
        n1: 100, // spline subdivisions 

        /**
         * Depth profile subdivisions.
         * @memberof RIPSAW.mesh
         * @type {number}
         */
        n2: 30,

        /**
         * Number of control points in depth profile objects.
         * @memberof RIPSAW.mesh
         * @type {number}
         */
        nP: 3

    },

    /**
     * Design geometry.
     * @memberof RIPSAW
     * @type {Object}
     */
    masterPiece: {},

    /**
     * Padding.
     * @memberof RIPSAW
     * @type {number}
     */
    padding: 0

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


RIPSAW.textAssets = {

    shapeLibrary: {

        "fork": "M812.146,568.452c-52.453,1.613-75.052-19.368-75.052-19.368s25.041-21.028,75.859-20.174c71.82,1.211,104.502-31.494,104.502-31.494s-36.717-34.678-106.52-33.871c-57.942,0.672-72.765-19.906-72.765-19.906s11.267-17.453,58.642-16.405c73.03,1.612,132.834-23.802,132.834-23.802c-267.869-111.5-264.88,45.689-424.959,35.904C290.183,426.229,63.01,307.15,70.535,484.526c6.455,152.186,145.255,64.558,422.294,69.399c189.035,3.305,216.292,149.023,434.714,45.998C927.543,599.924,880.07,566.362,812.146,568.452z",
        "person": "M75.303,533.052c6.047-65.575,80.289-100.945,124.724-54.667c49.041,51.07,127.95-12.528,71.852-141.562c-53.526-123.12,98.943-150.686,76.232-11.144C330.313,435.04,450.169,454.823,531.399,448.803c119.931-8.888,240.646-99.284,282.131-141.198c74.615-75.384,147.605,80.856,42.819,114.361c-102.57,32.796-177.442,45.126-174.202,107.489c3.158,60.764,63.259,100.824,165.825,102.922c139.445,2.85,65.561,197.484-31.098,111.666c-94.177-83.614-222.416-138.441-306.662-140.58C372.517,599.966,323.882,636.691,354.5,746.05c31.259,111.651-124.696,102.712-87.589,1.838c47.478-129.076,8.109-209.991-58.472-152.687C155.535,640.734,68.186,610.213,75.303,533.052z",
        "moustache": "M745.947,405.463c106.682,88.078,192.916,26.735,192.916,26.735C754.697,759.384,501.959,567.383,501.959,567.383C272.733,769.18,61.138,463.543,61.138,463.543c56.816,43.103,128.065,50.273,186.069-7.729c58.006-58.005,162.409-123.742,254.752,27.065C560.734,350.4,659.676,334.236,745.947,405.463z"

    },

    SVGHeader: [

        '<svg version="1.1" id="trace" ',
        'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ',
        'viewBox="0 0 200 100" ',
        'style="enable-background:new 0 0 200 100;" xml:space="preserve" >',

    ].join("\n"),

    SVGFooter: '</svg>',

    rhinoPythonScriptHeader: [

        '\n"""\n\nScript file generated by Yourk, www.RIPSAW.com/Yourk/experiment_1',
        '\nInstructions:',
        '\t- copy this code and paste it into a *.py file',
        '\t- open Rhino (rhino3d.com). The software is currently in development for Mac and free to use. Commercial license is needed for Windows. [stay tuned for a SketchUp implementation]',
        '\t- type RunPythonScript in the Rhino command line, and select your file.',
        '\t- in the current development phase, the geometry generated by this script needs to be trimmed manually to obtain the final 3d model. Stay tuned for full automation.',
        '\t- Rhino exports seamlessly into .stl format, which is directly imported into MakerWare, the software used to send geometries to MakerBot 3d printers. Check out the image gallery under RIPSAW.com/design/Yourk/ for images of the very first Yourk 3d printing process.',
        '\n"""',
        '\nimport rhinoscriptsyntax as rs\n\nimport math\n\ndef Main():\n\n'

    ].join('\n'),

    rhinoPythonScriptFooter: 'Main()'

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** Assign touch handlers corresponding to mouse event handlers. */
RIPSAW.touchHandler = function(event) {

    var touch = event.changedTouches[0],
        simulatedEvent = document.createEvent("MouseEvent");

    simulatedEvent.initMouseEvent({

        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup"

    }[event.type], true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);

    touch.target.dispatchEvent(simulatedEvent);

    // event.preventDefault();

    return this;

};


/** Assigns touch handlers defined by RIPSAW.touchHandler. */
RIPSAW.addTouchHandlers = function() {

    document.addEventListener("touchstart", this.touchHandler, true);
    document.addEventListener("touchmove", this.touchHandler, true);
    document.addEventListener("touchend", this.touchHandler, true);
    document.addEventListener("touchcancel", this.touchHandler, true);

    return this;

};


/** Creates and appends canvas element to container div (ID set to RIPSAW.canvas.id). */
RIPSAW.createCanvas = function() {

    this.canvas = document.createElement("canvas");
    this.canvas.id = "ripsaw-canvas";

    this.ctx = this.canvas.getContext("2d");
    this.ctx.lineCap = "round";
    this.canvas.style.margin = "auto";

    this.container.appendChild(this.canvas);

    return this;

};

/** Adds default mouse event listeners. To be replaced with mouse observer pattern. */
RIPSAW.addDefaultEventListeners = function() {

    // add default mouse event listeners
    if (typeof this.mouseDown === "undefined") {

        RIPSAW.mouseDown = function(e) {

            e.preventDefault();

            if (!e.which && e.button) {

                if (e.button & 1) {
                    e.which = 1;
                } // Left
                else if (e.button & 4) {
                    e.which = 2;
                } // Middle
                else if (e.button & 2) {
                    e.which = 3;
                } // Right

            }

            if (e.which === 1) {

                RIPSAW.mouse.update(e, 'down');
                RIPSAW.masterPiece.mouseDown();

            } else if (e.which === 3) {

                RIPSAW.masterPiece.mouseDownRight();

            }



        };

    }

    if (typeof this.mouseMove === "undefined") {

        RIPSAW.mouseMove = function(e) {

            RIPSAW.mouse.update(e, 'move');
            RIPSAW.masterPiece.mouseMove();

        };

    }

    if (typeof this.mouseUp === "undefined") {

        RIPSAW.mouseUp = function(e) {

            RIPSAW.mouse.update(e, 'up');
            RIPSAW.masterPiece.mouseUp();

        };

    }

    if (typeof this.keyPressed === "undefined") {

        RIPSAW.keyPressed = function(e) {

            RIPSAW.masterPiece.keyPressed();

        };

    }

    this.canvas.addEventListener('mousedown', this.mouseDown);
    this.canvas.addEventListener('mousemove', this.mouseMove);
    this.canvas.addEventListener('mouseup', this.mouseUp);

    window.addEventListener('keypressed', this.keyPressed);

    return this;

};


/** Recalculates canvas width and height upon browser window resize. */
RIPSAW.resize = function() {

    var cst = RIPSAW.container.style,
        totalVerticalPadding, totalHorizontalPadding;

    //totalVerticalPadding = cst.paddingTop + cst.paddingBottom;
    //totalHorizontalPadding = cst.paddingLeft + cst.paddingRight;

    totalVerticalPadding = totalHorizontalPadding = 2 * RIPSAW.padding;

    RIPSAW.W = RIPSAW.container.clientWidth - totalVerticalPadding;
    RIPSAW.H = RIPSAW.container.clientHeight - totalHorizontalPadding;

    // width/height may get negative if app is run in a modal which is has not fully appeared yet (foundation)
    if (RIPSAW.W < 0 || RIPSAW.H < 0) {

        RIPSAW.W = 0;
        RIPSAW.H = 0;

        setTimeout(RIPSAW.resize, 200);

    }

    RIPSAW.minWH = Math.min(RIPSAW.W, RIPSAW.H);
    RIPSAW.maxWH = Math.max(RIPSAW.W, RIPSAW.H);

    RIPSAW.canvas.width = RIPSAW.W;
    RIPSAW.canvas.height = RIPSAW.H;

    return this;

};


/** Initializes application. */
RIPSAW.init = function() {

    this.container = document.getElementById(this.containerID);
    this.createCanvas();

    this.isModified = false;

    this.addDefaultEventListeners();

    this.addTouchHandlers();
    window.addEventListener('resize', RIPSAW.resize, false);

    this.resize();

    return this;

};


/** Sets basic drawing parameters. */
RIPSAW.prepDraw = function() {

    RIPSAW.ctx.fillStyle = RIPSAW.colors.get(0, 1);
    RIPSAW.pen.solidRect(0, 0, RIPSAW.W, RIPSAW.H);
    RIPSAW.ctx.textAlign = "center";
    RIPSAW.ctx.textBaseline = "middle";
    RIPSAW.time = new Date().getTime();

    return this;

};


/** Launches application. */
RIPSAW.launch = function() {

    RIPSAW.resize();

    RIPSAW.draw = RIPSAW.draw || function() {

        RIPSAW.prepDraw();
        RIPSAW.masterPiece.draw();

    };

    setInterval(RIPSAW.draw, RIPSAW.refreshInterval);

    return this;

};


/** Tears down application by removing attached canvas element. */
RIPSAW.tearDown = function() {

    this.canvas.parentNode.removeChild(this.canvas);

    return this;

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


RIPSAW.events = {

    on: function(name, callback) {

        this._events = (this._events || {});

        var events = this._events[name] || (this._events[name] = []);

        events.push({

            callback: callback

        });

    },

    off: function(name, callback) {

        var nm,
            ev = this._events[name],
            i, max,
            index = -1;

        i = 0;
        max = ev.length;

        for (i = 0; i < max; i += 1) {

            if (ev[i].callback === callback) {

                index = i;

            }

        }

        if (index !== -1) {

            ev.splice(index, 1);

        }

    },

    trigger: function(name) {

        var events = this._events[name] || [],
            i, max = events.length;

        for (i = 0; i < max; i += 1) {

            events[i].callback();

        }

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * Constructs observer instances in the functional pattern.
 * @namespace observer
 * @memberof RIPSAW
 */
RIPSAW.observer = function() {

    var subscribers = [],
        self = {};

    /** 
     * Returns subscriber's index in private subscribers array.
     * @memberof RIPSAW.observer
     * @param {Object} subscriber
     */
    self.indexOf = function(subscriber) {

        return subscribers.indexOf(subscriber);

    };


    /** 
     * Returns subscriber at a given index.
     * @memberof RIPSAW.observer
     * @param {number} index
     * @returns {Object} subscriber
     */
    self.getSubscriber = function(index) {

        return subscribers[index];

    };


    /** 
     * Subscribes object to observer.
     * @memberof RIPSAW.observer
     * @param {Object} subscriber
     * @returns {Object} this
     */
    self.subscribe = function(subscriber) {

        subscribers.push(subscriber);

        return self;

    };


    /** 
     * Unsubscribes object from observer.
     * @memberof RIPSAW.observer
     * @param {Object} subscriber
     * @returns {Object} this
     */
    self.unsubscribe = function(subscriber) {

        var index = this.indexOf(subscriber);

        if ((typeof index !== "undefined") && (index !== -1)) {

            subscribers.splice(index, 1);

        }

        return self;

    };


    /** 
     * Fires method on all subscribers.
     * @memberof RIPSAW.observer
     * @param {String} methodName - Method to be called on subscribers.
     * @returns {Object} this
     */
    self.fire = function(methodName) {

        var i, max = subscribers.length,
            subscriber;

        for (i = 0; i < max; i += 1) {

            subscriber = subscribers[i];

            if ((typeof subscriber !== "undefined") && (typeof subscriber[methodName] !== "undefined")) {

                subscriber[methodName]();

            }

        }

    };

    return self;

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * Prototypal inheritance.
 * @param {Object} o - Inherited object.
 * @returns {Object} F - New constructor instance.
 */
RIPSAW.inherit = function(object) {

    function F() {}
    F.prototype = object;
    return new F();

};


/** 
 * Prototypal inheritance.
 * @param {Function} Parent - Parent constructor.
 * @param {Function} Child - Child constructor.
 * @returns {Object} F - New constructor instance.
 */
RIPSAW.inheritPrototype = function(Parent, Child) {

    var key;

    if (typeof Child === "undefined") {

        Child = function() {};

    }

    for (key in Parent.prototype) {

        Child.prototype[key] = Parent.prototype[key];

    }

    return Child;

};


/** 
 * Simple bind.
 * @param {Function} method - Method to bind.
 * @param {Object} object - Object to bind to.
 */
RIPSAW.bind = function(method, object) {

    return function() {

        return method.apply(object, Array.prototype.slice.call(arguments));

    };

};


/** 
 * Shallow copy of own properties only. No objects are copied from the prototype.
 * @param {object} [child={}] - Child object to copy into. If unspecified, a new object is returned.
 * @param {object} parent - Parent object.
 */
RIPSAW.extend = function(child, parent) {

    var prop;

    child = child || {};

    for (prop in parent) {

        if (parent.hasOwnProperty(prop)) {

            child[prop] = parent[prop];

        }

    }

    return child;

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * Returns whether two numbers are nearly equal (RIPSAW.delta).
 * @param {number} n1 - First number.
 * @param {number} n2 - Second number.
 * @param {number} [delta] - Overrides globla delta definition.
 * @returns {boolean}
 */
RIPSAW.areNearEqual = function(n1, n2, deltaArg) {

    var delta = (typeof deltaArg === "undefined") ? RIPSAW.delta : deltaArg;

    return Math.abs(n1 - n2) < delta;

};


/**
 * Maps vector to canvas dimensions.
 * @param {RIPSAW.Vector} p
 * @returns {RIPSAW.Vector}
 */
RIPSAW.map = function(p) {

    return new RIPSAW.Vector(p.x * RIPSAW.W, p.y * RIPSAW.H, 0);

};


/**
 * Calculates sine wave evolution in a given timeframe.
 * @param {number} time
 * @param {number} period
 * @param {number} [startPhase=0]
 * @param {number} [startTime=0]
 * @param {number} [endTime=10000]
 * @returns {number}
 */
RIPSAW.sineAnimate = function(time, period, startPhase, startTime, endTime) {

    var t;

    if ((RIPSAW.time - RIPSAW.time0) < startTime) {

        t = 0;

    } else if ((RIPSAW.time - RIPSAW.time0) > endTime) {

        t = endTime - startTime;

    } else {

        t = (RIPSAW.time - RIPSAW.time0) - startTime;

    }

    return Math.sin(t / period * 2 * Math.PI + startPhase);

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * @constructor
 * @param {number} rows - Number of rows.
 * @param {number} columns - Number of columns.
 */
RIPSAW.Matrix = function(rows, columns) {

    /** @type {number} */
    this.n = rows || 2;

    /** @type {number} */
    this.m = columns || 2;

    /** @type {Array} */
    this.table = [];

    for (var i = 0; i < this.n; i += 1) {

        this.table.push([]);

        for (var j = 0; j < this.m; j += 1) {

            this.table[i].push(0);

        }

    }

    return this;

};


RIPSAW.Matrix.prototype = {


    /**
     * Returns String representation.
     * @returns {String}
     */
    toString: function() {

        var s = "Matrix " + this.n + " x " + this.m + "\n",
            i, j;

        for (i = 0; i < this.n; i += 1) {

            s += "|";

            for (j = 0; j < this.m; j += 1) {

                s += " " + this.table[i][j] + " ";

            }

            s += "|\n";

        }

        console.log(new RIPSAW.Matrix(2, 2).populate(1, 0, 0, 1).inverse());

        return s;

    },


    /**
     * Populates Matrix with an array of numbers (traversing to the right, then down).
     * @param {numbers} [args] List of numbers.
     * @returns {RIPSAW.Matrix} this
     */
    populate: function() {

        var i, max = arguments.length;

        for (i = 0, max = arguments.length; i < max; i += 1) {

            this.table[Math.floor(i / this.m)][i % this.m] = arguments[i];

        }

        return this;

    },


    /**
     * Returns determinant. Implemented for 2x2 only.
     * @returns {number} determinant
     */
    determinant: function() {

        var t = this.table;

        if (this.n === 2 && this.m === 2) {

            return t[0][0] * t[1][1] - t[0][1] * t[1][0];

        }

    },


    /**
     * Returns Matrix inverse. Does not modify object! Implemented for 2x2 only.
     * @returns {RIPSAW.Matrix} inverse
     */
    inverse: function() {

        var det = this.determinant(),
            resultMatrix = new RIPSAW.Matrix(this.n, this.m);

        if (det === 0) return undefined;

        if (this.n === 2 && this.m === 2) {

            resultMatrix.table[0][0] = +this.table[1][1] / det;
            resultMatrix.table[1][0] = -this.table[1][0] / det;
            resultMatrix.table[0][1] = -this.table[0][1] / det;
            resultMatrix.table[1][1] = +this.table[0][0] / det;

        }

        return resultMatrix;

    },


    /**
     * Returns product with second matrix. Does not modify object!
     * @param {RIPSAW.Matrix} m2
     * @returns {RIPSAW.Matrix} mp
     */
    multiply: function(m2) {

        var i, j, i1,
            m1 = this,
            mp = new RIPSAW.Matrix(m1.n, m2.m),
            value;

        for (i = 0; i < m1.n; i += 1) {

            for (j = 0; j < m2.m; j += 1) {

                value = 0;

                for (i1 = 0; i1 < m1.m; i1 += 1) {

                    value += m1.table[i][i1] * m2.table[i1][j];

                }

                mp.table[i][j] = value;

            }

        }

        this.n = mp.n;
        this.m = mp.m;

        this.table = [];

        for (i = 0; i < this.n; i += 1) {

            this.table.push([]);

            for (j = 0; j < this.m; j += 1) {

                this.table[i].push(mp.table[i][j]);

            }

        }

        return this;

    },


    /**
     * Returns deep copy.
     * @returns {RIPSAW.Matrix}
     */
    clone: function() {

        var i, j,
            m = new RIPSAW.Matrix(this.n, this.m);

        for (i = 0; i < this.n; i += 1) {

            for (j = 0; j < this.m; j += 1) {

                m.table[i][j] = this.table[i][j];

            }

        }

        return m;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {number} [x=0] - x-coordinate.
 * @param {number} [y=0] - y-coordinate.
 * @param {number} [z=0] - z-coordinate.
 */
RIPSAW.Vector = function(x, y, z) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

    return this;

};

RIPSAW.Vector.prototype = {

    /** Set constructor. */
    constructor: RIPSAW.Vector,


    /** 
     * Logs vector in a x: 0 | y: 0 | z: 0 form.
     * @param {number} [decimals=2] Number of decimal places.
     */
    log: function(decimals) {

        var d = decimals || 2;

        return "x: " + this.x.toFixed(d) + " | y: " + this.y.toFixed(d) + " | z: " + this.z.toFixed(d);

    },


    /** 
     * Logs vector in a [0, 0, 0] form.
     * @param {number} [decimals=2] Number of decimal places.
     * @returns {string}
     */
    toString: function(decimals) {

        var d = decimals || 2;

        return "[" + this.x.toFixed(d) + "," + this.y.toFixed(d) + "," + this.z.toFixed(d) + "]";

    },


    // DEPRECATED
    // matches with vTarget if difference in coordinates less than dMin
    match: function(vTarget) {

        var dx = Math.abs(this.x - vTarget.x),
            dy = Math.abs(this.y - vTarget.y),
            dz = Math.abs(this.z - vTarget.z),
            x, y, z;

        if ((dx < RIPSAW.delta) && (dy < RIPSAW.delta) && (dz < RIPSAW.delta)) {

            this.x = vTarget.x;
            this.y = vTarget.y;
            this.z = vTarget.z;

        }

        return this;

    },


    /** 
     * Returns whether vector is near equal to target vector (coordinates within RIPSAW.delta).
     * @param {Object} v - Target vector.
     * @returns {boolean}
     */
    isNearEqualTo: function(v) {

        return (Math.abs(this.x - v.x) < RIPSAW.delta && Math.abs(this.y - v.y) < RIPSAW.delta && Math.abs(this.z - v.z) < RIPSAW.delta);

    },


    /** 
     * Returns distance to target vector.
     * @param {Object} v - Target vector.
     * @returns {number}
     */
    getDistanceTo: function(v) {

        return Math.pow(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2) + Math.pow(this.z - v.z, 2), 0.5);

    },


    /** 
     * Returns Manhattan distance to target vector.
     * @param {Object} v - Target vector.
     * @returns {number}
     */
    getManhattanDistanceTo: function(v) {

        return (Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z));

    },


    /** 
     * Normalizes vector.
     * @param {number} [length=1] - Target length.
     * @returns {Object} this
     */
    normalize: function(length) {

        var d = this.getDistanceTo(new RIPSAW.Vector(0, 0, 0)),
            k = (d !== 0) ? ((length || 1.0) / d) : 1;

        this.x *= k;
        this.y *= k;
        this.z *= k;

        return this;

    },


    /** 
     * Adds another vector. Modifies object!
     * @param {Object} v - Target vector.
     * @returns {Object} this
     */
    add: function(v) {

        if (v instanceof RIPSAW.Vector) {

            this.x += (v.x || 0);
            this.y += (v.y || 0);
            this.z += (v.z || 0);

        }

        return this;

    },


    /** 
     * Subtracts another vector. Modifies object!
     * @param {Object} v - Target vector.
     * @returns {Object} this
     */
    subtract: function(v) {

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },


    /** 
     * Uniformly scales vector coordinates. Modifies object!
     * @param {number} k - Scale factor.
     * @returns {Object} this
     */
    scale: function(k) {

        this.x *= k;
        this.y *= k;
        this.z *= k;

        return this;

    },


    /** 
     * Returns dot product with target vector. Does not modify object!
     * @param {Object} v - Target vector.
     * @returns {Object} this
     */
    dotProduct: function(v) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },


    // DEPRECATED
    product: function(v) {

        return this.getProduct(v);

    },


    /** 
     * Returns piecewise product with target vector. Does not modify object!
     * @param {Object} v - Target vector.
     * @returns {Object} product - Resulting vector.
     */
    getProduct: function(v) {

        return new RIPSAW.Vector(this.x * v.x, this.y * v.y, this.z * v.z);

    },


    /** 
     * Cross multiplies vector with target vector. Modifies object!
     * @param {Object} v - Target vector.
     * @returns {Object} this
     */
    crossMultiply: function(v) {

        var x = +this.y * v.z - this.z * v.y,
            y = -this.x * v.z + this.z * v.x,
            z = +this.x * v.y - this.y * v.x;

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },


    /** 
     * Returns cross product with target vector. Does not modify object!
     * @param {Object} v - Target vector.
     * @returns {Object} this
     */
    getCrossProduct: function(v) {

        return this.clone().crossMultiply(v);

    },


    /** 
     * Returns deep copy displaced by target vector. Does not modify object!
     * @param {Object} [v={ x:0, y:0, z:0 }] - Displacement vector.
     * @returns {Object} vect - Cloned and displaced vector.
     */
    clone: function(v) {

        return new RIPSAW.Vector(this.x, this.y, this.z).add(v);

    },


    /** 
     * Returns a linear combination of an array of vectors. Does not modify objects!
     * @param {Array} [vectors] - Array of vectors to be evaluated.
     * @returns {Object} result - Linear combination.
     */
    getLinearCombination: function(vectors, coefficients) {

        var n = Math.min(vectors.length, coefficients.length),
            x = 0,
            y = 0,
            z = 0;

        for (var i = 0; i < n; i += 1) {

            x += vectors[i].x * coefficients[i];
            y += vectors[i].y * coefficients[i];
            z += vectors[i].z * coefficients[i];

        }

        return new RIPSAW.Vector(x, y, z);

    },


    /** 
     * Swaps Y and Z coordinates. Modifies object!
     * @param {Array} [vectors] - Array of vectors to be evaluated.
     * @returns {Object} result - Linear combination.
     */
    swapYZ: function() {

        var replace = this.y;

        this.y = this.z;
        this.z = replace;

        return this;

    },


    /** 
     * Projects onto camera. Modifies object!
     * @param {Array} [vectors] - Array of vectors to be evaluated.
     * @returns {Object} result - Linear combination.
     */
    project: function(camera) {

        var v = camera.project(this);

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },


    /** 
     * Returns Rhino PythonScript output.
     * @param {String} [arrayName] - Name of structure.
     * @returns {Object} result - Linear combination.
     */
    toRhinoPythonScript: function() {

        return "[" +
            this.x.toFixed(2) + "," +
            this.y.toFixed(2) + "," +
            this.z.toFixed(2) + "]";

    },


    /** 
     * Returns Rhino PythonScript output as an array append.
     * @param {String} [arrayName] - Name of structure.
     * @returns {Object} result - Linear combination.
     */
    toRhinoPythonScriptArray: function(arrayName) {

        var exportScript = "\t" + arrayName + ".append(" +
            this.toRhinoPythonScript() + ")\n";

        return exportScript;

    },

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {number} x x-coordinate.
 * @param {number} y y-coordinate.
 * @param {number} z z-coordinate.
 * @param {number} [cx] x-constraint. 1 if free, 0 if fixed.
 * @param {number} [cy] y-constraint. 1 if free, 0 if fixed.
 * @param {number} [cz] z-constraint. 1 if free, 0 if fixed.
 */
RIPSAW.DragNode = function(x, y, z, cx, cy, cz) {

    if (x instanceof RIPSAW.Vector) {

        /** @type {RIPSAW.Vector} */
        this.temp = new RIPSAW.Vector(x.x, x.y, x.z);

    } else {

        this.temp = new RIPSAW.Vector(x, y, z);

    }

    /** @type {RIPSAW.Vector} */
    this.perm = this.temp.clone();

    /** @type {RIPSAW.Vector} */
    this.constraints = new RIPSAW.Vector(cx || 1.0, cy || 1.0, cz || 1.0);

    return this;

};

RIPSAW.DragNode.prototype = {

    constructor: RIPSAW.DragNode,

    /** 
     * Update permanent coordinates to temporary ones.
     * @returns {RIPSAW.DragNode} this
     */
    update: function() {

        this.perm = this.temp.clone();

        return this;

    },

    /** 
     * Revert temporary coordinates to permanent ones.
     * @returns {RIPSAW.DragNode} this
     */
    revert: function() {

        this.temp = this.perm.clone();

        return this;

    },

    /** 
     * Revert temporary coordinates to permanent ones.
     * @returns {RIPSAW.DragNode} this
     */
    setDrag: function(v) {

        this.temp = this.perm.clone(v.getProduct(this.constraints));

        return this;

    },

    /** 
     * Get drag (difference between temporary and permanent coordinates).
     * @returns {RIPSAW.Vector} Drag amount.
     */
    getDrag: function() {

        return this.temp.clone().subtract(this.perm);

    },

    /** 
     * Returns deep copy.
     * @returns {RIPSAW.DragNode}
     */
    clone: function() {

        return new RIPSAW.DragNode(this.perm.x, this.perm.y, this.perm.z, this.constraints.x, this.constraints.y, this.constraints.z);

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {Array} args - Points.
 */
RIPSAW.PointCloud = function(args) {

    /** @type {Array} */
    this._list = [];

    var pt, pts, max, i;

    if (arguments[0] instanceof Array) {

        pts = arguments[0];

        for (i = 0, max = pts.length; i < max; i += 1) {

            pt = pts[i];
            this._list.push(new RIPSAW.Vector(pt.x || 0, pt.y || 0, pt.z || 0));

        }

    }

    return this;

};

RIPSAW.PointCloud.prototype = {


    /** 
     * Adds point to list.
     * @param {RIPSAW.Vector} v - New vector.
     */
    addPoint: function(v) {

        this._list.push(v);

        return this;

    },


    /** 
     * Returns point at specified index.
     * @param {number} index
     * @returns {RIPSAW.Vector}
     */
    getPoint: function(index) {

        return this._list[index];

    },


    /**
     * Returns number of points in cloud.
     * @returns {number}
     */
    getPointCount: function() {

        return this._list.length;

    },


    /**
     * Sorts by x-coordinates.
     * @returns {RIPSAW.PointCloud} this
     */
    sortX: function() {

        this._list.sort(function(a, b) {
            return (a.x > b.x) ? 1 : -1;
        });

        return this;

    },


    /**
     * Sorts by y-coordinates.
     * @returns {RIPSAW.PointCloud} this
     */
    sortY: function() {

        this._list.sort(function(a, b) {
            return (a.y > b.y) ? 1 : -1;
        });

        return this;

    },


    /**
     * Sorts by z-coordinates.
     * @returns {RIPSAW.PointCloud} this
     */
    sortZ: function() {

        this._list.sort(function(a, b) {
            return (a.z > b.z) ? 1 : -1;
        });

        return this;

    },


    /**
     * Returns bounding box.
     * @returns {{min:RIPSAW.Vector,max:RIPSAW.Vector}} obj - Lower and upper corner of the box: { min: , max: }.
     */
    getBoundingBox: function() {

        var maxX = -5000,
            minX = +5000,
            maxY = -5000,
            minY = +5000,
            maxZ = -5000,
            minZ = +5000,
            i, max = this._list.length,
            pt;

        for (i = 0; i < max; i += 1) {

            pt = this.getPoint(i);

            if (pt.x > maxX) maxX = pt.x;
            if (pt.y > maxY) maxY = pt.y;
            if (pt.z > maxZ) maxZ = pt.z;

            if (pt.x < minX) minX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.z < minZ) minZ = pt.z;

        }

        return {
            min: new RIPSAW.Vector(minX, minY, minZ),
            max: new RIPSAW.Vector(maxX, maxY, maxZ)
        };

    },


    /**
     * For a given x, finds points on the piecewise straight polyline connecting subsequent points of the cloud.
     * @returns {Array|RIPSAW.Vector}
     */
    interpolateX: function(x) {

        var i, max = this._list.length,
            p1, p2, targetLine, result = [];

        for (i = 0; i < max - 1; i += 1) {

            p1 = this._list[i];
            p2 = this._list[i + 1];

            if ((p1.x === x) || (p2.x === x) ||
                (p1.x < x && p2.x > x) ||
                (p1.x > x && p2.x < x)) {

                result.push(new RIPSAW.Line(p1, p2).interpolateX(x));

            }

        }

        return result;

    },


    /**
     * Returns length of the !open! polyline defined by the pointcloud. Assume open polyline.
     * @returns {number}
     */
    getLength: function() {

        var i, max = this._list.length,
            result = 0;

        for (i = 0; i < max - 1; i += 1) {

            result += this._list[i].getDistanceTo(this._list[i + 1]);

        }

        return result;

    },


    /**
     * Returns length of the !closed! polyline defined by the pointcloud.
     * @returns {number}
     */
    getClosedLength: function() {

        return this.getLength() + this._list[this._list.length - 1].getDistanceTo(this._list[0]);

    },


    /**
     * Draws polyline formed by the pointcloud.
     * @param {function} [mappingFunction=identity] Mapping function used to transform nodes.
     * @returns {number}
     */
    draw: function(mappingFunction) {

        var i,
            max = this.getPointCount(),
            map = mappingFunction || function(x) {
                return x;
            };

        RIPSAW.pen.start();
        RIPSAW.pen.moveTo(map(this.getPoint(0)));
        for (i = 1; i < max; i += 1) {

            RIPSAW.pen.lineTo(map(this.getPoint(i)));

        }
        RIPSAW.pen.end();

        return this;

    },


    /**
     * Returns SVG output.
     * @returns {String}
     */
    toSVG: function() {

        var i, max = this.getPointCount(),
            pt,
            result = '<polyline fill="none" stroke="black" stroke-linecap="round" stroke-linejoin="round" points = "';

        for (i = 0; i < max; i += 1) {

            pt = this.getPoint(i);

            result += pt.x.toFixed(6) + ',' + pt.y.toFixed(6) + ' ';

        }

        result += '" />';

        return result;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {RIPSAW.Vector} v1 - Startpoint.
 * @param {RIPSAW.Vector} v2 - Endpoint.
 */
RIPSAW.Line = function(v1, v2) {

    /** @type {RIPSAW.Vector} */
    this.p1 = v1.clone();

    /** @type {RIPSAW.Vector} */
    this.p2 = v2.clone();

    return this;

};


RIPSAW.Line.prototype = {

    /** 
     * Returns point along line.
     * @param {number} s - Curve parameter (0 at startpoint, 1 at endpoint).
     * @returns {RIPSAW.Vector}
     */
    pointAt: function(s) {

        var x = this.p1.x * (1 - s) + this.p2.x * s,
            y = this.p1.y * (1 - s) + this.p2.y * s,
            z = this.p1.z * (1 - s) + this.p2.z * s;

        return new RIPSAW.Vector(x, y, z);

    },


    /** 
     * Returns whether the start- and endpoints of the line are within .
     * @param {number} s - Curve parameter (0 at startpoint, 1 at endpoint).
     * @returns {boolean} true
     */
    hasInBoundingRectangleXY: function(p) {

        return (p.x >= Math.min(this.p1.x, this.p2.x)) &&
            (p.x <= Math.max(this.p1.x, this.p2.x)) &&
            (p.y >= Math.min(this.p1.y, this.p2.y)) &&
            (p.y <= Math.max(this.p1.y, this.p2.y));

    },


    /** 
     * Draws line.
     * @returns {RIPSAW.Line} this
     */
    draw: function() {

        var mappingFunction = (typeof arguments[0] !== "undefined") ? arguments[0] : function(x) {
            return x;
        };

        RIPSAW.line(mappingFunction(this.p1), mappingFunction(this.p2));

        return this;

    },


    /** 
     * Reverses line.
     * @returns {RIPSAW.Line} this
     */
    reverse: function() {

        var replace = this.p1;

        this.p1 = this.p2;
        this.p2 = replace;

        return this;

    },


    /** 
     * Returns equation of the line in XY plane as coefficients of a * x + b * y + c = 0.
     * @returns {Object} equation - Object in { a: , b: , c: } format.
     */
    getEquationXY: function() {

        // 0 = a * x + b * y + c
        var a, b, c;

        if (this.p1.x === this.p2.x) {

            a = 1;
            b = 0;
            c = -this.p1.x;

        } else {

            a = (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
            b = -1;
            c = this.p2.y - a * this.p2.x;

        }

        return {

            a: a,
            b: b,
            c: c

        };

    },


    /** 
     * Returns new line of unit length perpendicular to the line, originating from the midpoint.
     * @returns {RIPSAW.Line} midPerpXY
     */
    getMidPerpXY: function() {

        var v = this.p1.clone().subtract(this.p2),
            startPoint = this.p1.clone().scale(0.5).add(this.p2.clone().scale(0.5));

        v.crossMultiply(new RIPSAW.Vector(0, 0, 1)).normalize();

        return new RIPSAW.Line(startPoint, startPoint.clone().add(v));

    },


    /** 
     * Scales line with respect to the startpoint. Modifies object!
     * @returns {RIPSAW.Line} this
     */
    scale: function(factor) {

        var v = this.p2.clone().subtract(this.p1).scale(factor);

        this.p2 = this.p1.clone().add(v);

        return this;

    },


    /** 
     * Returns distance from point to line, projecting both onto XY plane.
     * @param {RIPSAW.Vector} p - Point
     * @returns {RIPSAW.Line} this
     */
    getDistanceFromXY: function(p) {

        var eq = this.getEquationXY(),
            d = Math.pow(Math.pow(eq.a, 2) + Math.pow(eq.b, 2) + Math.pow(eq.c, 2), 0.5);

        return Math.abs(eq.a * p.x + eq.b * p.y + eq.c) / d;

    },


    /**
     * Returns point on line with a given x coordinate.
     * @param {RIPSAW.Vector} xTarget
     * @returns {RIPSAW.Vector}
     */
    interpolateX: function(xTarget) {

        var s, result;

        if (RIPSAW.areNearEqual(this.p1.x, this.p2.x)) return this.p1.clone();

        s = (xTarget - this.p1.x) / (this.p2.x - this.p1.x);

        result = this.p1.clone().scale(1 - s);
        result.add(this.p2.clone().scale(s));

        return result;

    },


    /**
     * Returns intersection with another line in a complex object. See specs for usage examples.
     * @param {RIPSAW.Line} l2
     * @param {number} delta2 - Override overlap tolerance defined
     * @returns {Object}
     */
    intersectXY: function(l2, delta2Arg) {

        // l1.p1.x + (l1.p2.x - l1.p1.x) * s1 = l2.p1.x + (l2.p2.x - l2.p1.x) * s2 (1)
        // l1.p1.y + (l1.p2.y - l1.p1.y) * s1 = l2.p1.y + (l2.p2.y - l2.p1.y) * s2 (2)
        //    matrix form: K * [ s1 ; s2 ] = M  {colon indicates row break in matrix}
        //	  solve for S = [ s1 ; s2 ] = K-1 * M
        // substitute results on the left side of (1) and (2) to obtain coordinates

        var l1 = this,
            K, M, S, s1, s2, intersect,
            i, j,
            type,
            pc,
            delta2 = (typeof delta2Arg === "undefined") ? RIPSAW.delta2 : delta2Arg;

        //console.log(delta2);

        K = new RIPSAW.Matrix(2, 2).populate(+(l1.p2.x - l1.p1.x), -(l2.p2.x - l2.p1.x), +(l1.p2.y - l1.p1.y), -(l2.p2.y - l2.p1.y));


        if (Math.abs(K.determinant()) < RIPSAW.delta) {

            if (this.getDistanceFromXY(l2.p1) < delta2) {

                if (l1.hasInBoundingRectangleXY(l2.p1) || l1.hasInBoundingRectangleXY(l2.p2)) {

                    pc = new RIPSAW.PointCloud([this.p1.clone(), this.p2.clone(), l2.p1.clone(), l2.p2.clone()]).sortX().sortY();

                    return {

                        points: [pc.getPoint(1).clone(), pc.getPoint(2).clone()],
                        type: "overlap"

                    };

                } else {

                    return {

                        points: [],
                        type: "outerlap"

                    };

                }

            } else return {

                points: [],
                type: "parallel"

            };

        }

        M = new RIPSAW.Matrix(2, 1).populate(
            l2.p1.x - l1.p1.x,
            l2.p1.y - l1.p1.y
        );

        S = K.clone().inverse().multiply(M);

        s1 = S.table[0][0];
        s2 = S.table[1][0];

        return {

            points: [l1.pointAt(s1)],
            type: (s1 >= 0 && s1 <= 1 && s2 >= 0 && s2 <= 1) ? "inside" : "outside",
            s1: s1,
            s2: s2

        };

    },


    /**
     * Returns line angle measured from +x, projected onto XY plane.
     * @returns {number}
     */
    getAngleXY: function() {

        var angle,
            v1 = this.p1,
            v2 = this.p2;

        if (Math.abs(v1.x - v2.x) < 1e-5 && v2.y > v1.y) return Math.PI / 2;

        if (Math.abs(v1.x - v2.x) < 1e-5 && v2.y < v1.y) return 3 * Math.PI / 2;

        angle = Math.atan((v2.y - v1.y) / (v2.x - v1.x));

        if (v1.x < v2.x) {

            if (angle < 0) return angle + 2 * Math.PI;
            return angle;

        }

        return angle + Math.PI;

    },


    /**
     * Returns SVG representation.
     * @returns {String}
     */
    toSVG: function() {

        var result = '<line fill="none" stroke="black" stroke-linecap="round" stroke-linejoin="round" ';

        result += 'x1 = "' + this.p1.x.toFixed(6) + '" ';
        result += 'y1 = "' + this.p1.y.toFixed(6) + '" ';
        result += 'x2 = "' + this.p2.x.toFixed(6) + '" ';
        result += 'y2 = "' + this.p2.y.toFixed(6) + '" ';

        result += '/>';

        return result;

    },


    toRhinoPythonScript: function() {

        return "rs.AddLine(" + this.p1.toRhinoPythonScript() + ", " + this.p2.toRhinoPythonScript() + ")";

    },


    clone: function() {

        return new RIPSAW.Line(this.p1.clone(), this.p2.clone());

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {number} [r=1] - Radial distance from source (cylindrical coordinate).
 * @param {number} [theta=pi/3] - Horizontal rotation (cylindrical coordinate).
 * @param {number} [phi=-pi/4] - Vertical rotation (cylindrical coordinate).
 * @param {number} [f=0.6] - Focal length.
 */
RIPSAW.Camera = function(r, theta, phi, f) {

    this.r = this.rT = (typeof r !== "undefined") ? r : 1;
    this.theta = this.thetaT = (typeof theta !== "undefined") ? theta : (Math.PI / 3);
    this.phi = this.phiT = (typeof phi !== "undefined") ? phi : (-Math.PI / 4);
    this.f = (typeof f !== "undefined") ? f : (0.6); // focal length

    this.eye = new RIPSAW.Vector();

    // Local axes
    this.v1 = new RIPSAW.Vector(1, 0, 0); // in view direction
    this.v2 = new RIPSAW.Vector(0, 1, 0); // prependicular to view direction, in the horizontal plane
    this.v3 = new RIPSAW.Vector(0, 0, 1); // prependicular to view direction, in the vertical plane

    this.buildEye();

    return this;

};

RIPSAW.Camera.prototype = {

    /** Calculate position and orientation of the camera. */
    buildEye: function() {

        // Calculate camera position (polar -> cartesian).
        this.eye = new RIPSAW.Vector(

            this.rT * Math.cos(this.thetaT) * Math.cos(this.phiT),
            this.rT * Math.sin(this.thetaT) * Math.cos(this.phiT),
            this.rT * Math.sin(this.phiT)

        ).normalize();

        // Establishes local axes -> all normalized
        this.v1 = this.eye.clone().scale(-1);
        this.v2 = this.v1.clone().crossMultiply(new RIPSAW.Vector(0, 0, 1)).normalize();
        this.v3 = this.v2.clone().crossMultiply(this.v1);

        return this;

    },


    /** 
     * Update permanent spherical coordinates to temporary ones.
     * @returns {RIPSAW.Camera} this
     */
    update: function() {

        this.r = this.rT;
        this.theta = this.thetaT;
        this.phi = this.phiT;

        return this;

    },


    /** 
     * Revert temporary spherical coordinates to permanent ones.
     * @returns {RIPSAW.Camera} this
     */
    revert: function() {

        this.rT = this.r;
        this.thetaT = this.theta;
        this.phiT = this.phi;

        this.buildEye();

        return this;

    },


    /** 
     * Project point onto camera. Does not modify point!
     * @param {RIPSAW.Vector} p - Point to project.
     * @param {RIPSAW.Vector} projection
     */
    project: function(p) {

        var xProject, yProject, zProject,
            direction = this.eye.clone().subtract(p);

        // Calculate position in the local axis of the camera.
        xProject = direction.dotProduct(this.v2);
        yProject = direction.dotProduct(this.v3);
        zProject = direction.dotProduct(this.v1);

        return new RIPSAW.Vector(

            xProject * this.f / zProject,
            yProject * this.f / zProject,
            0

        );

    },


    /** 
     * Constrain view height <=> phi between +80 and -80 degrees.
     * @returns {RIPSAW.Camera} this
     */
    constrainViewHeight: function() {

        var phiMax = 80 * Math.PI / 180;

        if (this.phiT < -phiMax) this.phiT = -phiMax;
        if (this.phiT > +phiMax) this.phiT = +phiMax;

        return this;

    },


    /** 
     * Sets offset between temporary and permanent spherical coordinates based on mouse displacements.
     * @returns {RIPSAW.Camera} this
     */
    setDrag: function() {

        var drag = RIPSAW.mouse.getDrag();

        this.thetaT = this.theta - drag.x / RIPSAW.minWH * 2;
        this.phiT = this.phi - drag.y / RIPSAW.minWH * 2;

        return this;

    },


    /** Callback executed on mouseDrag. */
    mouseDrag: function() {

        this.setDrag().constrainViewHeight().buildEye();

        return this;

    },


    /** Callback executed on mouseMove. */
    mouseMove: function() {

        if (RIPSAW.mode === "3dpreview" && RIPSAW.mouse.isDragging) {

            this.setDrag().constrainViewHeight().buildEye();

        }

        return this;

    },


    /** Callback executed on mouseUp. */
    mouseUp: function() {

        this.update();

        return this;

    },


    /** Callback executed on mouseDown. */
    mouseDown: function() {

        return this;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * @namespace colors
 * @memberof RIPSAW
 */
RIPSAW.colors = {

    /**
     * Color scheme as object of [r, g, b] arrays (see code comments).
     * @type {Object}
     * @memberof RIPSAW.colors
     */
    schemes: {
        // purple scheme
        purple: [
            [61, 56, 79], // 0: background
            [247, 141, 52], // 1: title
            [203, 168, 114], // 2: subtitle
            [61, 103, 196], // 3: misc text
            [95, 52, 247], // 4: control handle endpoints
            [61, 103, 196], // 5: control handle midpoint
            [95, 90, 113], // 6: nav bounding boxes
            [255, 255, 255] // 7: curve strokes	
        ],
        // black and white scheme
        bw: [
            [255, 255, 255],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ]
    },


    /**
     * Key of active color scheme.
     * @type {String}
     * @memberof RIPSAW.colors
     */
    activeScheme: "purple",


    /**
     * Returns color from colorscheme.
     * @param {number} index
     * @param {number} opacity
     */
    get: function(index, opacity) {

        var aSchI = this.schemes[this.activeScheme][index];

        return "rgba(" + aSchI[0] + "," + aSchI[1] + "," + aSchI[2] + "," + (opacity) + ")";

    },


    /**
     * Returns color between two colors corresponding to two indeces.
     * @param {number} index1 - Start color.
     * @param {number} index2 - End color.
     * @param {number} s - Parameter (0 at start, 1 at end).
     * @param {number} opacity
     * @returns {String} color - JavaScript 'rgba( , , , )' representation.
     */
    getBetween: function(index1, index2, s, opacity) {

        var aSch = this.schemes[this.activeScheme],
            color = [
                aSch[index1][0] * s + aSch[index2][0] * (1 - s),
                aSch[index1][1] * s + aSch[index2][1] * (1 - s),
                aSch[index1][2] * s + aSch[index2][2] * (1 - s)
            ];

        return "rgba(" + Math.round(color[0]) + "," + Math.round(color[1]) + "," + Math.round(color[2]) + "," + opacity + ")";

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * @namespace pen
 * @memberof RIPSAW
 */
RIPSAW.pen = {

    /**
     * Display stroke weights and circle radii - relative to minWH.
     * @type {Object}
     * @memberof RIPSAW.pen
     */
    displayDimensions: {

        nav: {

            outline: 1 / 500,
            buttonSize: 0.03

        }

    },

    /**
     * Display style settings.
     * @type {Object}
     * @memberof RIPSAW.pen
     */
    styles: {

        "design outline": {

            dim: 1 / 200,
            strokeColor: 7,
            fillColor: 1

        },

        "design iso": {

            dim: 1 / 500,
            strokeColor: 7,
            fillColor: 1

        },

        "design thin": {

            dim: 1 / 1000,
            strokeColor: 7,
            fillColor: 1

        },

        "nav bounding box": {

            dim: 1 / 500,
            strokeColor: 6

        },

        "design handle": {

            dim: 1 / 300,
            strokeColor: 7,
            fillColor: 1

        },

        "control point": {

            dim: 1 / 100,
            strokeColor: 1,
            fillColor: 5

        },

        "primary control point": {

            dim: 1 / 100,
            strokeColor: 1,
            fillColor: 4

        },

        "secondary control point": {

            dim: 1 / 100,
            strokeColor: 1,
            fillColor: 5

        },

        "point": {

            dim: 1 / 150,
            strokeColor: 1,
            fillColor: 2

        }

    },


    /**
     * Configures strokes, fills and radius for specific drawing situation (RIPSAW-CSS).
     * @memberof RIPSAW.pen
     * @param {String} type
     */
    configure: function(type) {

        var style = RIPSAW.pen.styles[type];

        RIPSAW.pen.stroke(style.dim || 1 / 100);
        RIPSAW.pen.radius(style.dim);
        RIPSAW.pen.color.stroke(style.strokeColor || 1);
        RIPSAW.pen.color.fill(style.fillColor || 1);

    },


    /**
     * Draws solid rectangle.
     * @memberof RIPSAW.pen
     * @param {number} x - Start x-coordinate.
     * @param {number} y - Start y-coordinate.
     * @param {number} w - Width.
     * @param {number} h - Height.
     */
    solidRect: function(x, y, w, h) {

        RIPSAW.ctx.beginPath();
        RIPSAW.ctx.rect(x, y, w, h);
        RIPSAW.ctx.closePath();
        RIPSAW.ctx.fill();

    },

    /**
     * Writes text on canvas.
     * @memberof RIPSAW.pen
     * @param {String} s - String to place.
     * @param {number} x - x-coordinate (relative to W).
     * @param {number} y - y-coordinate (relative to H).
     * @param {number} fontSizeRelative - Font size relative to default.
     * @param {number} colorCodingIndex - Color code from colorscheme.
     * @param {number} opacity
     */
    write: function(s, x, y, fontSizeRelative, colorCodingIndex, opacity) {

        RIPSAW.ctx.fillStyle = RIPSAW.colors.get(colorCodingIndex, opacity);
        RIPSAW.ctx.font = "" + RIPSAW.W * RIPSAW.wDisplay.text * fontSizeRelative + "px " + RIPSAW.fonts;
        RIPSAW.ctx.fillText(s, RIPSAW.W * x, RIPSAW.H * y);

    },


    /**
     * Begins path.
     * @memberof RIPSAW.pen
     */
    start: function() {

        RIPSAW.ctx.beginPath();

    },


    /**
     * Ends path.
     * @memberof RIPSAW.pen
     */
    end: function() {

        RIPSAW.ctx.stroke();

    },


    /**
     * Moves cursor.
     * @memberof RIPSAW.pen
     * @param {RIPSAW.Vector}
     */
    moveTo: function(v) {

        RIPSAW.ctx.moveTo(v.x, v.y);

    },


    /**
     * Draws line to point.
     * @memberof RIPSAW.pen
     * @param {RIPSAW.Vector}
     */
    lineTo: function(v) {

        RIPSAW.ctx.lineTo(v.x, v.y);

    },


    /**
     * Draws line between two points.
     * @memberof RIPSAW.pen
     * @param {RIPSAW.Vector} v1 - Startpoint.
     * @param {RIPSAW.Vector} v2 - Endpoint.
     */
    line: function(v1, v2) {

        this.start();
        this.moveTo(v1);
        this.lineTo(v2);
        this.end();

    },


    arc: function(v, r, angleRange) {

        if (r > 0) {

            this.start();
            RIPSAW.ctx.arc(v.x, v.y, r, angleRange.theta1, angleRange.theta2);
            this.end();

        }

    },


    splineTo: function(v1, v2, v3) {

        RIPSAW.ctx.bezierCurveTo(v1.x, v1.y, v2.x, v2.y, v3.x, v3.y);

    },


    solidCircle: function(v, r) {

        r = (typeof r === "undefined") ? RIPSAW.defaultRadius : r * RIPSAW.minWH;

        RIPSAW.ctx.beginPath();
        RIPSAW.ctx.arc(v.x, v.y, r, 0, Math.PI * 2, true);
        RIPSAW.ctx.fill();

    },


    controlPoint: function(v, doubleRadius, isSecondary) {

        var r = RIPSAW.defaultRadius;
        r = doubleRadius ? (2 * r) : r;

        RIPSAW.pen.solidCircle(v, r);

    },


    stroke: function(r) {

        RIPSAW.ctx.lineWidth = r * RIPSAW.minWH;

    },


    radius: function(r) {

        RIPSAW.defaultRadius = r;

    },


    color: {

        stroke: function(i, opacity) {

            RIPSAW.ctx.strokeStyle = RIPSAW.colors.get(i, opacity || 1);

        },

        fill: function(i, opacity) {

            RIPSAW.ctx.fillStyle = RIPSAW.colors.get(i, opacity || 1);

        }

    },


    animateCircle: function(v, r1, r2, color1, color2, t1, t2) {

        var r, color, colorCode, c1;

        if ((RIPSAW.time - RIPSAW.time0) >= t1 && (RIPSAW.time - RIPSAW.time0) <= t2) {

            c1 = (t2 - RIPSAW.time + RIPSAW.time0) / (t2 - t1); // goes from 1 to 0
            r = r1 * c1 + r2 * (1 - c1);

            RIPSAW.ctx.strokeStyle = RIPSAW.colors.getBetween(color1, color2, c1, c1);
            RIPSAW.ctx.lineWidth = RIPSAW.minWH / 200;
            RIPSAW.pen.arc(RIPSAW.map(v), r * RIPSAW.minWH, {
                theta1: 0,
                theta2: 2 * Math.PI
            });

        }

    },


    boundingBox: function(corner, dimension, r) {

        var x = corner.x,
            y = corner.y,
            w = dimension.x,
            h = dimension.y;

        RIPSAW.pen.line({
            x: x + r,
            y: y
        }, {
            x: x + w - r,
            y: y
        });

        RIPSAW.pen.line({
            x: x + w,
            y: y + r
        }, {
            x: x + w,
            y: y + h - r
        });

        RIPSAW.pen.line({
            x: x + w - r,
            y: y + h
        }, {
            x: x + r,
            y: y + h
        });

        RIPSAW.pen.line({
            x: x,
            y: y + h - r
        }, {
            x: x,
            y: y + r
        });

        RIPSAW.pen.arc({
            x: x + r,
            y: y + r
        }, r, {
            theta1: Math.PI * 1,
            theta2: Math.PI * 1.5
        });

        RIPSAW.pen.arc({
            x: x + w - r,
            y: y + r
        }, r, {
            theta1: Math.PI * 1.5,
            theta2: Math.PI * 2
        });

        RIPSAW.pen.arc({
            x: x + r,
            y: y + h - r
        }, r, {
            theta1: Math.PI / 2,
            theta2: Math.PI * 1
        });

        RIPSAW.pen.arc({
            x: x + w - r,
            y: y + h - r
        }, r, {
            theta1: Math.PI * 2,
            theta2: Math.PI * 2.5
        });

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * Created using the immediately invoked functional pattern, inheriting from observer.
 * @namespace mouse
 * @memberof RIPSAW
 */
RIPSAW.mouse = (function() {

    var that = {},
        x = 0, // current mouse position
        y = 0,
        xDrag = 0, // mouse position at the start of dragging
        yDrag = 0,
        _events = ["up", "down", "move"]; // object to be returned


    // inherit from observer
    that = RIPSAW.observer();

    /**
     * True if mouse is dragging.
     * @memberof! RIPSAW.mouse
     * @type {boolean}
     */
    that.isDragging = false;


    /** 
     * @memberof! RIPSAW.mouse
     * @type {RIPSAW.Observer}
     */
    //that.obs = new RIPSAW.Observer();


    /** 
     * Updates mouse position.
     * @memberof! RIPSAW.mouse
     * @param {Object}
     */
    that.getPosition = function(event) {

        var rect = RIPSAW.canvas.getBoundingClientRect();

        x = event.clientX - rect.left;
        y = event.clientY - rect.top;

    };


    /** 
     * Returns mouse drag.
     * @memberof! RIPSAW.mouse
     * @param {Object}
     * @returns {RIPSAW.Vector}
     */
    that.getDrag = function() {

        return new RIPSAW.Vector(x - xDrag, y - yDrag, 0);

    };


    /** 
     * Returns mouse drag normalized to app width and height.
     * @memberof! RIPSAW.mouse
     * @returns {RIPSAW.Vector}
     */
    that.getNormalizedDrag = function() {

        return this.getDrag().product(new RIPSAW.Vector(1 / RIPSAW.W, 1 / RIPSAW.H));

    };


    /** 
     * Returns distance of the mouse cursor to target vector.
     * @memberof! RIPSAW.mouse
     * @param {RIPSAW.Vector} v - Target vector.
     * @returns {number} distance
     */
    that.distanceTo = function(v) {

        return new RIPSAW.Vector(x, y).getDistanceTo(v);

    };


    /** 
     * Returns whether mouse hovers a given point.
     * @memberof! RIPSAW.mouse
     * @param {RIPSAW.Vector} v - Target vector.
     * @returns {boolean}
     */
    that.hovers = function(v) {

        return this.distanceTo(v) < (RIPSAW.minWH * RIPSAW.tolerance);

    };


    /** 
     * Returns position relative to target vector.
     * @memberof! RIPSAW.mouse
     * @param {RIPSAW.Vector} v - Target vector.
     * @returns {RIPSAW.Vector}
     */
    that.positionTo = function(v) {

        return new RIPSAW.Vector(x - v.x, y - v.y);

    };


    /** 
     * Updates mouse.
     * @memberof! RIPSAW.mouse
     * @param {Object} event - Event.
     */
    that.update = function(event, mouseState) {

        this.getPosition(event);

        if (mouseState === "down") {

            this.isDragging = true;
            xDrag = x;
            yDrag = y;

        } else if (mouseState === "up") {

            this.isDragging = false;

        }

    };


    /** 
     * Callback fired on mousedown.
     * @memberof! RIPSAW.mouse
     * @returns {Object} this
     */
    that.down = function(event) {

        this.update(event, 'down');
        this.obs.fire('mouseDown');

        return this;

    };


    /** 
     * Callback fired on mouseup.
     * @memberof! RIPSAW.mouse
     * @returns {Object} this
     */
    that.up = function(event) {

        this.update(event, 'up');
        this.obs.fire('mouseDown');

        return this;

    };


    /** 
     * Callback fired on mousemove.
     * @memberof! RIPSAW.mouse
     * @returns {Object} this
     */
    that.move = function(event) {

        this.update(event, 'move');
        this.obs.fire('mouseMove');

        return this;

    };

    return that;

}());





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * Created using the immediately invoked functional pattern, inheriting from observer.
 * @namespace stage
 * @memberof RIPSAW
 */
RIPSAW.stage = (function() {

    var that = {};

    // inherit from observer
    that = RIPSAW.observer();

    /** 
     * Stage number.
     * @memberof RIPSAW.stage
     * @type {number}
     */
    that.no = 0;


    /** 
     * Update stage number.
     * @memberof RIPSAW.stage
     */
    that.update = function() {

        this.fire("stageUpdate");
        RIPSAW.time0 = RIPSAW.time;

        return this;

    };


    /** 
     * Change stage number. Round to 1 decimal place.
     * @memberof RIPSAW.stage
     * @param {number} inc - Increment.
     */
    that.change = function(inc) {

        this.no = Math.round((this.no + inc) * 10) / 10;
        this.update();

        return this;

    };


    /** 
     * Set stage number. Round to 1 decimal place.
     * @memberof RIPSAW.stage
     * @param {number} target
     */
    that.set = function(target) {

        this.no = Math.round(target * 10) / 10;
        this.update();

        return this;

    };

    return that;

}());





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * @namespace tutorial
 * @memberof RIPSAW
 */
RIPSAW.tutorial = {

    /** 
     * Start x-coordinate (Relative to W).
     * @memberof RIPSAW.tutorial
     * @type {number}
     */
    x: 0.5,

    /** 
     * x-offset for subsequent tutorial texts.
     * @memberof RIPSAW.tutorial
     * @type {number}
     */
    dx: 0,

    /** 
     * Start y-coordinate (Relative to H).
     * @memberof RIPSAW.tutorial
     * @type {number}
     */
    y: 0.75,

    /** 
     * y-offset for subsequent tutorial texts.
     * @memberof RIPSAW.tutorial
     * @type {number}
     */
    dy: 0.05,

    /** 
     * Array of texts to be displayed.
     * @memberof RIPSAW.tutorial
     * @type {Array}
     */
    text: [],


    /** 
     * Place tutorial.
     * @memberof RIPSAW.tutorial
     */
    place: function() {

        if (typeof text !== "undefined") {

            var i, max = text.length;

            for (i = 0; i < max; i += 1) {

                RIPSAW.pen.write(this.text[i], this.x + i * this.dx, this.y + i * this.dy, 1, 2, 1);

            }

        }

    },


    /** 
     * Callback fired on stage update.
     * @memberof RIPSAW.tutorial
     */
    stageUpdate: function() {

        this.text = this.stageManager[RIPSAW.stage.no];

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @class
 * @param {number} x Display x coordinate, relative to canvas width.
 * @param {number} y Display y coordinate, relative to canvas height.
 * @param {String} name Button name.
 * @param {boolean} animate Display animation when new stage begins.
 */
RIPSAW.MenuButton = function(x, y, name, animate) {

    /** @type {String} */
    this.name = name;

    /** @type {boolean} */
    this.isActive = false;

    /** 
     * Centroid x-coordinate, relative to W.
     * @type {number}
     */
    this.x = x;

    /** 
     * Centroid y-coordinate, relative to H.
     * @type {number}
     */
    this.y = y;

    /** 
     * Button width, relative to maxWH.
     * @type {number}
     */
    this.w = RIPSAW.wDisplay.navButton;

    /** 
     * Button height, relative to maxWH.
     * @type {number}
     */
    this.h = RIPSAW.wDisplay.navButton;

    /**
     * Coefficient that controls opacity variations when button is hovered.
     * @type {number}
     */
    this.damping = 0.03;

    /** @type {number} */
    this.opacity = 0.4;

    /**
     * Target opacity of menubutton whether it is active or inactive.
     * @type {Object}
     */
    this.targetOpacity = {

        true: 1,
        false: 0.4

    };

    // if true, short animation is displayed to signal to the user that the button is new in the environment (new tutorial stage)
    this.animate = animate || false;

};

RIPSAW.MenuButton.prototype = {

    /**
     * Returns whether button is hovered.
     * @returns {boolean}
     */
    isHovered: function() {

        var positionFromMouse = RIPSAW.mouse.positionTo(RIPSAW.map(this));

        return (Math.abs(positionFromMouse.x) < this.w * RIPSAW.maxWH / 2) && (Math.abs(positionFromMouse.y) < this.h * RIPSAW.W / 2);

    },


    /**
     * Changes display opacity towards corresponding targetOpacity value.
     * @returns {RIPSAW.MenuButton} this
     */
    setDisplayOpacity: function() {

        this.opacity += (this.targetOpacity[this.isActive] - this.opacity) * this.damping;

        if (RIPSAW.ctx) {

            RIPSAW.ctx.globalAlpha = this.opacity;

        }

        return this;

    },


    /**
     * Animates marking circle around menubutton to show the user that it is new to the scene.
     * @returns {RIPSAW.MenuButton} this
     */
    animateMarkingCircle: function() {

        RIPSAW.ctx.globalAlpha = 1;

        if (this.animate) {

            RIPSAW.pen.animateCircle(

                this,
                0.05, 0.12, 2, 0,
                RIPSAW.anim.delay, RIPSAW.anim.delay + 500

            );

        }

        return this;

    },


    /**
     * Places button on screen.
     * @returns {RIPSAW.MenuButton} this
     */
    place: function() {

        this.setDisplayOpacity();

        RIPSAW.ctx.drawImage(

            RIPSAW.allButtons[this.name].image,

            RIPSAW.map(this).x - this.w * RIPSAW.maxWH / 2,
            RIPSAW.map(this).y - this.h * RIPSAW.maxWH / 2,

            this.w * RIPSAW.maxWH,
            this.h * RIPSAW.maxWH

        );

        this.animateMarkingCircle();

        return this;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @class
 * @param {Object} navInfo Input object for navigation.
 */
RIPSAW.Navigation = function(navInfo) {

    /** 
     * Array of buttons.
     * @type {Array}
     */
    this.buttons = [];

    /** 
     * Array of button groups. A button group is an array of member indeces from buttons array.
     * @type {Array}
     */
    this.buttonGroups = [];

    /** 
     * Index of hovered menubutton.
     * @type {number}
     */
    this.hoverIndex = -1;

    /** 
     * Whether help text should be displayed.
     * @type {boolean}
     */
    this.displayHelp = true;

    /** 
     * Display x coordinate for help text (relative to W).
     * @type {number}
     */
    this.helpX = 0.5;

    /** 
     * Display y coordinate for help text (relative to H).
     * @type {number}
     */
    this.helpY = 0.5;

    /** 
     * Name of menubutton active by default.
     * @type {Array}
     */
    this.defaultMode = "mode2";

    if (typeof navInfo !== "undefined") {

        this.build(navInfo);

    }

};

RIPSAW.Navigation.prototype = {

    /**
     * Builds navigation from array of simplified menubutton constructor. See spec for example.
     */
    build: function(navInfo) {

        var i, max;

        this.displayHelp = navInfo.displayHelp || true;
        this.defaultMode = navInfo.defaultMode || "mode2";
        this.helpX = navInfo.xHelp || 0.5;
        this.helpY = navInfo.yHelp || 0.5;

        this.buttons = [];
        this.buttonGroups = [];

        if (typeof navInfo !== "undefined") {

            for (i = 0, max = navInfo.buttons.length; i < max; i += 1) {

                this.buttons.push(new RIPSAW.MenuButton(

                    navInfo.buttons[i].x,
                    navInfo.buttons[i].y,
                    navInfo.buttons[i].name,
                    navInfo.buttons[i].animate

                ));

            }

            this.buttonGroups = navInfo.buttonGroups || [];

        }

    },


    /** Callback fired on mouse down. */
    mouseDown: function() {

        if (this.hoverIndex !== -1 && (typeof this.hoverIndex !== "undefined")) {

            RIPSAW.allButtons[this.buttons[this.hoverIndex].name].onClick();

        }

    },


    /** Callback fired on mouse move. */
    mouseMove: function() {

        var i, max = this.buttons.length;

        this.hoverIndex = -1;

        for (i = 0; i < max; i += 1) {

            // check if the mouse is over the button
            if (this.buttons[i].isHovered()) {

                this.hoverIndex = i;
                this.buttons[i].isActive = true;

            } else {

                this.buttons[i].isActive = false;

            }

            // if current active mode equals the name of the button, set back to active
            if (this.buttons[i].name === RIPSAW.mode) {

                this.buttons[i].isActive = true;

            }

        }

        return this;

    },


    /** Place buttons. */
    placeButtons: function() {

        var i, max = this.buttons.length;

        for (i = 0; i < max; i += 1) {

            this.buttons[i].place();

        }

        return this;

    },


    /** Place help. */
    placeHelp: function() {

        if (this.displayHelp && (this.hoverIndex !== -1)) {

            if (typeof this.buttons[this.hoverIndex] !== "undefined") {

                RIPSAW.pen.write(
                    RIPSAW.allButtons[this.buttons[this.hoverIndex].name].helpText,
                    this.helpX, this.helpY, 1, 2, (this.buttons[this.hoverIndex].opacity - 0.4) / 0.6
                );

            }

        }

        return this;

    },


    /** 
     * Returns boundaries for button group.
     * @param {number} buttonGroupIndex - Index of button group.
     */
    getButtonGroupBoundaries: function(buttonGroupIndex) {

        var group = this.buttonGroups[buttonGroupIndex],
            i, max = group.length,
            maxX = -5000,
            maxY = -5000,
            minX = +5000,
            minY = +5000,
            x, y;

        for (i = 0; i < max; i++) {

            x = this.buttons[group[i]].x;
            y = this.buttons[group[i]].y;

            if (maxX < x) maxX = x;
            if (maxY < y) maxY = y;
            if (minX > x) minX = x;
            if (minY > y) minY = y;

        }

        return {
            min: new RIPSAW.Vector(minX, minY),
            max: new RIPSAW.Vector(maxX, maxY)
        };

    },


    /** 
     * Places bounding box around button groups.
     * @returns {RIPSAW.Navigation} this
     */
    placeBoundingBoxes: function() {

        var i, max,
            v1, v2,
            boxDim,
            radius,
            bound;

        for (i = 0, max = this.buttonGroups.length; i < max; i += 1) {

            bound = this.getButtonGroupBoundaries(i);

            v1 = bound.min;
            v2 = bound.max.subtract(bound.min);

            boxDim = RIPSAW.wDisplay.navButton * RIPSAW.W * 1.3;
            radius = 0.025 * RIPSAW.minWH;

            RIPSAW.pen.boundingBox(

                RIPSAW.map(v1).subtract(new RIPSAW.Vector(boxDim / 2, boxDim / 2)),
                RIPSAW.map(v2).add(new RIPSAW.Vector(boxDim, boxDim)),
                radius

            );

        }

        return this;

    },


    /**
     * Draw navigation.
     * @returns {RIPSAW.Navigation} this
     */
    draw: function() {

        this.placeButtons();
        this.placeHelp();

        RIPSAW.pen.configure("nav bounding box");
        this.placeBoundingBoxes();

    },


    /** Callback fired on stage change. */
    stageUpdate: function() {

        var stageInfo = this.stageManager[RIPSAW.stage.no];

        if (typeof stageInfo !== "undefined") {

            this.build(stageInfo);
            RIPSAW.mode = this.defaultMode;

        }

        return this;

    }

};

RIPSAW.nav = new RIPSAW.Navigation();





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {number} x0 Drawing origin x-coordinate (relative coordinates).
 * @param {number} y0 Drawing origin y-coordinate (relative coordinates).
 * @param {number} scale Scale factor.
 */
RIPSAW.MasterPiece = function(x0, y0, scale) {

    /** @type {String} */
    this.name = "object";

    /** @type {RIPSAW.DragNode} */
    this.centroid = new RIPSAW.DragNode(x0 || 0.5, y0 || 0.5);

    /** @type {number} */
    this.scale = scale || 1;

    /** @type {RIPSAW.MasterPiecePermissions} */
    this.allow = new RIPSAW.MasterPiecePermissions("11000");

    /** @type {Object} */
    this.stageManager = {};

    /** type {Object} */
    this.control = [];

    /** type {Number} */
    this.hoverIndex = -1;

};


RIPSAW.MasterPiece.prototype = {

    /** 
     * Maps geometry to canvas, taking into account view parameters (centroid and scale).
     * @param {RIPSAW.Vector} v
     * @returns {RIPSAW.Vector} v
     */
    map: function(v) {

        return new RIPSAW.Vector(

            this.centroid.temp.x * RIPSAW.W + v.x * RIPSAW.minWH * this.scale,
            this.centroid.temp.y * RIPSAW.H + v.y * RIPSAW.minWH * this.scale,
            0

        );

    },


    /** 
     * Update display information and permissions upon stage change.
     * @returns {RIPSAW.MasterPiece} this
     */
    updateState: function(state) {

        if (typeof state !== "undefined") {

            this.allow.setBinaryString(state.permissionsBinary || "0");
            this.centroid = new RIPSAW.DragNode(state.x0 || 0.5, state.y0 || 0.5);
            this.scale = state.scale || 1.0;

        }

        return this;

    },


    /** 
     * Get mousedrag relative to object display information. Ensures that correct mouse drag is applied regardless of zoom, scale and displacement.
     * @returns {RIPSAW.Vector}
     */
    getObjectDrag: function() {

        return RIPSAW.mouse.getDrag().getProduct(new RIPSAW.Vector(1 / RIPSAW.minWH / this.scale, 1 / RIPSAW.minWH / this.scale));

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {String} [binaryString="11000"] A string of 1's and 0's corresponding to allowed or not allowed for a given permission
 */
RIPSAW.MasterPiecePermissions = function(binaryString) {

    /** @type {Array} */
    this.permissionList = ["draw", "edit", "pan", "zoom", "rotate"];

    /** @type {String} */
    this.setBinaryString(binaryString || "11000");

    return this;

};


RIPSAW.MasterPiecePermissions.prototype = {

    /** 
     * Retrieves permission by index.
     * @param {number} index - Index in permissionList array to be retrieved.
     * @returns {boolean} permission
     */
    getByIndex: function(index) {

        return this[this.permissionList[index]];

    },


    /** 
     * Sets permission by index.
     * @param {number} index - Index in permissionList array to be set.
     * @returns {RIPSAW.MasterPiecePermissions} this
     */
    setByIndex: function(index, value) {

        this[this.permissionList[index]] = value;

        return this;

    },


    /** 
     * Sets permission based on binary string (0's or 1's).
     * @param {String} binaryString
     * @returns {RIPSAW.MasterPiecePermissions} this
     */
    setBinaryString: function(binaryString) {

        var i, max = this.permissionList.length;

        binaryString = (Object.prototype.toString.call(binaryString) === '[object String]') ? binaryString : "0";

        for (i = 0; i < max; i += 1) {

            this[this.permissionList[i]] = (binaryString.charAt(i) === "1");

        }

        return this;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {String} path - SVG path, e.g. "M10,10C20,20,30,30z"
 */
RIPSAW.BezierSVGPath = function(path) {

    this.raw = path; // raw svg path

    return this;

};

RIPSAW.BezierSVGPath.prototype = {

    /** 
     * Separates SVG path into an array of numbers and letters (e.g. c, s, l, C, S, L, z).
     * @returns {Array} result - Array of characters and numbers.
     */
    chop: function() {

        var i, path = this.raw,
            max = this.raw.length,
            c = "",
            s = "",
            result;

        result = [];

        for (i = 0; i < max; i += 1) {

            c = path.charAt(i);

            if (/[mMcCsSz]/.test(c)) {

                if (s !== '') {

                    result.push(parseFloat(s));

                }

                result.push(c);

                s = '';

            } else if (c === ",") {

                if (s !== '') {

                    result.push(parseFloat(s));

                }

                s = '';

            } else if (c === "-") { // in SVG files, commas are sometimes ommitted

                if (s !== '') {

                    result.push(parseFloat(s));

                }

                s = '-';

            } else {

                s = s + c;

            }

        }

        if (s !== '') {

            result.push(parseFloat(s));

        }

        return result;

    },


    /** 
     * Packages x-y coordinate pairs into vectors.
     * @returns {Array} result - Array of characters and RIPSAW.Vector objects.
     */
    vectorize: function() {

        var processed = this.chop(),
            result = [],
            i, max = processed.length,
            x, y, c, numberCounter = 0;

        for (i = 0; i < max; i += 1) {

            c = processed[i];

            if (/[mMcCsSz]/.test(c)) {

                result.push(c);

            } else {

                if (numberCounter % 2 === 0) {

                    x = c;

                } else {

                    y = c;
                    result.push(new RIPSAW.Vector(x, y));

                }

                numberCounter += 1;

            }

        }

        return result;

    },


    /** 
     * Turns all coordinate references in SVG path into absolute (s -> S, c -> C). Modifies coordinates accordingly.
     * @returns {Array} result - Array of characters and RIPSAW.Vector objects.
     */
    absolutize: function() {

        var processed = this.vectorize(),
            i, i0 = -1,
            max = processed.length;

        for (i = 0; i < max; i += 1) {

            if (/[cs]/.test(processed[i])) {

                i0 = i;
                processed[i] = processed[i].toUpperCase();

            } else if (/[CS]/.test(processed[i])) {

                i0 = -1;

            } else if (i0 !== -1) {

                processed[i].add(processed[i0 - 1]);

            }

        }

        return processed;

    },


    /** 
     * Eliminates symmetric control handle shortcuts in SVG path.
     * @returns {Array} result - Array of characters and RIPSAW.Vector objects.
     */
    ridS: function() {

        var i,
            processed = this.absolutize(),
            max = processed.length,
            result = [];

        for (i = 0; i < max; i += 1) {

            if (processed[i] === "S") {

                result.push("C");

                result.push(processed[i - 1].clone().scale(2).subtract(processed[i - 2]));

            } else {

                result.push(processed[i]);

            }

        }

        return result;

    },


    /** 
     * Converts into an array of Bezier Handles.
     * @param {boolean} [isClosed=true] - True of curve is closed.
     * @param {Array} bnodes - Array of RIPSAW.BezierHandle objects.
     */
    toBezierHandles: function(isClosedArg) {

        var isClosed, rotate,
            processed = this.ridS(),
            i, max = processed.length,
            p1, p2, p3,
            bnodes = [];

        if (typeof isClosedArg === "undefined") {

            isClosed = true;

        }

        for (i = 2; i < max - 1; i += 1) {

            if (processed[i] === "C") {

                if (i === 2 && isClosed) { // edge case 1: if the curve is closed, the left handle end of the first handle is specified at the end of the SVG path

                    p1 = processed[max - 3];

                } else if (i === 2 && !isClosed) {

                    p1 = processed[i - 1]; // edge case 2: is the curve is not closed, p1 and p2 should be identical

                } else {

                    p1 = processed[i - 2]; // ordinary case

                }

                p2 = processed[i - 1];
                p3 = processed[i + 1];

                bnodes.push(new RIPSAW.BezierHandle(p1, p2, p3));

            }

        }

        // add last point if curve is not closed
        if (!isClosed) {

            p1 = processed[max - 2];
            p2 = processed[max - 1];
            p3 = processed[max - 1];

            bnodes.push(new RIPSAW.BezierHandle(p1, p2, p3));

        }

        return bnodes;

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @param {RIPSAW.Vector} v1 - Left handle end.
 * @param {RIPSAW.Vector} v2 - Middle handle point (on curve).
 * @param {RIPSAW.Vector} v3 - Right handle end.
 */
RIPSAW.BezierHandle = function(v1, v2, v3) {

    this.p = [

        new RIPSAW.DragNode(v1),
        new RIPSAW.DragNode(v2),
        new RIPSAW.DragNode(v3)

    ];

    // subdivisions
    this.n = 20;

    this.hoverType = -1;

    // constraints in 3 directions, (1, 1, 1) means the vector is not constrained
    this.constraint = new RIPSAW.Vector(1, 1, 1);

    return this;

};



RIPSAW.BezierHandle.prototype = {

    toString: function() {

        output += "[" + this.p[0].perm.x + ", " + this.p[0].perm.y + "] - ";
        output += "[" + this.p[1].perm.x + ", " + this.p[1].perm.y + "] - ";
        output += "[" + this.p[2].perm.x + ", " + this.p[2].perm.y + "]";
        output += "\n";

        return output;

    },

    update: function() {

        // update permanent coordinates to temporary ones
        this.p[0].update();
        this.p[1].update();
        this.p[2].update();

        return this;

    },

    clone: function() {

        return new RIPSAW.BezierHandle(

            new RIPSAW.DragNode(this.p[0].perm.x, this.p[0].perm.y, this.p[0].perm.z),
            new RIPSAW.DragNode(this.p[1].perm.x, this.p[1].perm.y, this.p[1].perm.z),
            new RIPSAW.DragNode(this.p[2].perm.x, this.p[2].perm.y, this.p[2].perm.z)

        );

    },


    revert: function() {

        // revert temporary coordinates to permanent ones
        this.p[0].revert();
        this.p[1].revert();
        this.p[2].revert();

    },


    getHandleLengths: function() {

        return {

            temp: [

                this.p[0].temp.getDistanceTo(this.p[1].temp),
                this.p[2].temp.getDistanceTo(this.p[1].temp)

            ],

            perm: [

                this.p[0].perm.getDistanceTo(this.p[1].perm),
                this.p[2].perm.getDistanceTo(this.p[1].perm)

            ]

        };

    },


    setHandleLength: function(handleIndex, handleLength) {

        var s, dv;

        s = 1 - handleLength / this.getHandleLengths().temp[handleIndex];

        if (Math.abs(s) < 10) {

            dv = this.p[1].temp.clone();

            dv.subtract(this.p[2 * handleIndex].temp);

            dv.scale(s);

            this.p[2 * handleIndex].temp.add(dv);

        }

        return this;

    },


    preserveHandleLength: function(handleIndex) {

        var handleLength = this.getHandleLengths().perm[handleIndex];

        this.setHandleLength(handleIndex, handleLength);

        return this;

    },


    // Make nodes 1, 2 and  3 colinear
    smooth: function() {

        var dx2 = this.p[2].temp.x - this.p[0].temp.x,
            dy2 = this.p[2].temp.y - this.p[0].temp.y,
            n,
            k;

        n = (dx2 === 0) ? 100 : (dy2 / dx2);

        k = (this.p[2].temp.x > this.p[1].temp.x) ? 1 : -1;

        this.p[2].temp = this.p[1].temp.clone().add(new RIPSAW.Vector(+k, +k * n));
        this.p[0].temp = this.p[1].temp.clone().add(new RIPSAW.Vector(-k, -k * n));

        this.preserveHandleLength(0);
        this.preserveHandleLength(1);

        this.update();

        return this;

    },

    drawControlHandles: function(mappingFunction) {

        mappingFunction = mappingFunction || (function(x) {
            return x;
        });
        RIPSAW.pen.line(mappingFunction(this.p[1].temp), mappingFunction(this.p[0].temp));
        RIPSAW.pen.line(mappingFunction(this.p[1].temp), mappingFunction(this.p[2].temp));

    },

    drawControlPoints: function(mappingFunction) {

        mappingFunction = mappingFunction || (function(x) {
            return x;
        });
        RIPSAW.pen.controlPoint(mappingFunction(this.p[0].temp), this.hoverType === i);

    },

    setDrag: function(drag0) {

        var l = this.getHandleLengths().temp,
            hT = this.hoverType,
            k,
            drag = drag0.clone().product(this.constraint);

        if (hT !== -1) {

            switch (hT) {

                case 1:

                    this.p[1].setDrag(drag);
                    this.p[0].setDrag(drag);
                    this.p[2].setDrag(drag);

                    break;

                case 0:
                case 2:

                    this.p[hT].setDrag(drag0);

                    if (/mode[2-3]/.test(RIPSAW.mode)) {

                        k = l[(2 - hT) / 2] / l[hT / 2];

                        if (Math.abs(k) < 10) {

                            this.p[2 - hT].setDrag(drag0.product(new RIPSAW.Vector(-k, -k)));

                            if (/mode2/.test(RIPSAW.mode)) {

                                this.preserveHandleLength((2 - hT) / 2);

                            }

                        }

                    }

            }


        }

        return this;

    },

    toRhinoPythonScript: function() {



    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @extends RIPSAW.MasterPiece
 * @param {String|Array} controlPoints - Control points either as SVG path ('M9,1,2...5,6z') or array of BezierHandles.
 * @param {boolean} [isClosed=true] True if the curve is closed.
 */
RIPSAW.Bezier2D = function(controlPoints) {

    // classical inheritance - prototype is inherited after subclass prototype is set
    RIPSAW.MasterPiece.call(this);

    /** 
     * Rotation.
     * @type {number}
     */
    this.theta = 0;

    /** @type {boolean} */
    this.isClosed = true;

    if (typeof(controlPoints) === 'string') {

        this.control = new RIPSAW.BezierSVGPath(controlPoints).toBezierHandles();

    } else {

        this.control = controlPoints;

    }

    return this;

};


RIPSAW.Bezier2D.prototype = {

    /** 
     * Returns string representation.
     * @returns {String}
     */
    toString: function() {

        var i, max = this.control.length,
            output = "";

        for (i = 0; i < max; i += 1) {

            output += this.control[i].toString();

        }

        return output;

    },


    /** 
     * Adds control point to the end of the control point array.
     * @param {Object} controlPoint control point
     */
    addControlPoint: function(controlPoint) {

        this.control.push(controlPoint);

    },


    /** 
     * Resets control point to a straight line .
     * @param {number} height y-coordinate of straight line.
     * @param {number} nDiv Number of divisions.
     */
    createDepthProfile: function(height, nDiv) {

        var i,
            div = nDiv || 3,
            h = height || 0.1;

        this.control = [];

        for (i = 0; i < div; i += 1) {

            this.control.push(new RIPSAW.BezierHandle(

                new RIPSAW.Vector((i - 0.3) / (div - 1) - 0.5, h, 0),
                new RIPSAW.Vector((i + 0.0) / (div - 1) - 0.5, h, 0),
                new RIPSAW.Vector((i + 0.3) / (div - 1) - 0.5, h, 0)

            ));

        }

        this.constrainEnds(new RIPSAW.Vector(0, 1, 1));

        this.n = 15;

        this.isClosed = false;

        return this;

    },


    /** 
     * Returns bounding rectangle.
     * @returns {Object} boundingRectangle - Minimum and maximum bounds in a { min: , max: } object.
     */
    getBoundingRectangle: function() {

        var maxX = -5000,
            maxY = -5000,
            minX = +5000,
            minY = +5000, // max/min coordinates for normalization
            i, max = this.control.length,
            ctrl;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];

            maxX = Math.max(maxX, ctrl.p[0].temp.x, ctrl.p[1].temp.x, ctrl.p[2].temp.x);
            minX = Math.min(minX, ctrl.p[0].temp.x, ctrl.p[1].temp.x, ctrl.p[2].temp.x);

            maxY = Math.max(maxY, ctrl.p[0].temp.y, ctrl.p[1].temp.y, ctrl.p[2].temp.y);
            minY = Math.min(minY, ctrl.p[0].temp.y, ctrl.p[1].temp.y, ctrl.p[2].temp.y);

        }

        return {

            min: new RIPSAW.Vector(minX, minY),
            max: new RIPSAW.Vector(maxX, maxY)

        };

    },


    /** 
     * Returns centroid.
     * @returns {RIPSAW.Vector} centroid
     */
    getCentroid: function() {

        var br = this.getBoundingRectangle();

        return new RIPSAW.Vector((br.max.x + br.min.x) / 2, (br.max.y + br.min.y) / 2);

    },


    /** 
     * Returns maximum flat dimension in x and y directions.
     * @returns {number} maxDim
     */
    getMaxDim: function() {

        var br = this.getBoundingRectangle();

        return Math.max(br.max.x - br.min.x, br.max.y - br.min.y);

    },


    /** 
     * Moves all control points.
     * @param {RIPSAW.Vector} displacement
     * @returns {RIPSAW.Bezier2D} this
     */
    moveGeometry: function(displacement) {

        var i, max = this.control.length,
            ctrl;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];

            ctrl.p[0].temp.add(displacement);
            ctrl.p[0].update();

            ctrl.p[1].temp.add(displacement);
            ctrl.p[1].update();

            ctrl.p[2].temp.add(displacement);
            ctrl.p[2].update();

        }

        return this;

    },


    /** Scales all control points with respect to the origin. */
    scaleGeometry: function(scaleFactor) {

        var i, max = this.control.length,
            ctrl,
            fact = scaleFactor || 1;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];

            ctrl.p[0].temp.scale(fact);
            ctrl.p[0].update();

            ctrl.p[1].temp.scale(fact);
            ctrl.p[1].update();

            ctrl.p[2].temp.scale(fact);
            ctrl.p[2].update();

        }

        return this;

    },


    /** Normalizes handles so that they fit in the (-0.5, -0.5) -> (+0.5, +0.5) rectangle. */
    normalize: function() {

        var centroid, scaleFactor;

        centroid = this.getCentroid();
        scaleFactor = 1 / this.getMaxDim();

        this.moveGeometry(centroid.scale(-1)).scaleGeometry(scaleFactor);

        return this;

    },


    /** 
     * Constrain endpoints such that they cannot be dragged in a given direction.
     * @param {Object} [constraint={ x: 1, y: 1, z: 1 }] - Constraint direction.
     */
    constrainEnds: function(constraint) {

        var constr = constraint || new RIPSAW.Vector(1, 1, 1);

        this.control[0].constraint = constraint;
        this.control[this.control.length - 1].constraint = constraint;

        return this;

    },


    /** 
     * Returns true if curve is closed.
     * @returns {boolean}
     */
    isClosed: function() {

        if (this.control.length === 0) return false;

        return this.control[0].p[1].perm.isNearEqualTo(this.control[this.control.length - 1].p[1].perm);

    },


    /** 
     * Sets the number of divisions for individual Bezier curve segments (between two BezierHandle objects), proportionally to segment length.
     * @param {number} nMax - Total number of division segments along length of the entire curve.
     */
    setSubdivisions: function(nMax) {

        var maxLength = 0,
            max, currentLength, lengths = [],
            i;

        for (i = 0, max = this.control.length; i < max; i += 1) {

            currentLength = this.getSegmentLength(i);

            lengths.push(currentLength);

            if (currentLength > maxLength) maxLength = currentLength;

        }

        for (i = 0, max = this.control.length; i < max; i += 1) {

            this.control[i].n = Math.floor(lengths[i] / maxLength * nMax);

        }

        return this;

    },


    /**
     * Returns the length of one segment.
     * @param {number} segmentIndex - Index of segment to be evaluated.
     * @param {number} [n=10] - Number of line segments used to evaluate the length (the higher, the more accurate).
     */
    getSegmentLength: function(segmentIndex, n) {

        var length = 0,
            nDiv = n || 10,
            i;

        for (i = 0; i < nDiv; i += 1) {

            p1 = this.getPoint(segmentIndex, i / (nDiv));
            p2 = this.getPoint(segmentIndex, (i + 1) / (nDiv));

            length += p1.getDistanceTo(p2);

        }

        return length;

    },


    /**
     * Returns point along curve.
     * @param {number} segmentIndex - Index of segment to be evaluated.
     * @param {number} s - Curve parameter along segment (0 at start, 1 at end).
     */
    getPoint: function(segmentIndex, s) {

        var p1, p2, p3, p4,
            nextSegmentIndex = (segmentIndex === this.control.length - 1) ? 0 : (segmentIndex + 1);

        p1 = this.control[segmentIndex].p[1].temp;
        p2 = this.control[segmentIndex].p[2].temp;
        p3 = this.control[nextSegmentIndex].p[0].temp;
        p4 = this.control[nextSegmentIndex].p[1].temp;

        return new RIPSAW.Vector().getLinearCombination(
            [p1, p2, p3, p4], [
                Math.pow(1 - s, 3) * Math.pow(s, 0),
                Math.pow(1 - s, 2) * Math.pow(s, 1) * 3,
                Math.pow(1 - s, 1) * Math.pow(s, 2) * 3,
                Math.pow(1 - s, 0) * Math.pow(s, 3)
            ]
        );

    },


    /**
     * Returns subdivision of the entire curve.
     * @param {number} segmentIndex - Index of segment to be evaluated.
     * @param {number} n - Number of subdivisions per segment. If not specified, number is taken for start-BezierHandle object for each segment.
     * @returns {RIPSAW.PointCloud} result - List of subdivision points.
     */
    getSubdivision: function(n) {

        var result = new RIPSAW.PointCloud(),
            max, segmentDiv, i, j;

        max = (this.isClosed) ? (this.control.length) : (this.control.length - 1);

        for (i = 0; i < max; i += 1) {

            segmentDiv = n || this.control[i].n;

            for (j = 0; j < segmentDiv; j += 1) {

                result.addPoint(this.getPoint(i, j / (segmentDiv - 1)));

            }

        }

        return result;

    },


    /** Place spline. */
    placeSpline: function() {

        var i, max = this.control.length,
            dd = RIPSAW.pen.displayDimensions;

        RIPSAW.pen.start();

        RIPSAW.pen.moveTo(this.map(this.control[0].p[1].temp));
        for (i = 1; i < max; i += 1) {

            RIPSAW.pen.splineTo(

                this.map(this.control[i - 1].p[2].temp),
                this.map(this.control[i].p[0].temp),
                this.map(this.control[i].p[1].temp)

            );

        }

        if (this.isClosed) {

            RIPSAW.pen.splineTo(

                this.map(this.control[max - 1].p[2].temp),
                this.map(this.control[0].p[0].temp),
                this.map(this.control[0].p[1].temp)

            );

        }

        RIPSAW.pen.end();

        return this;

    },


    /** Place control handles. */
    placeControlHandles: function() {

        var i, max = this.control.length,
            ctrl;



        for (i = 0; i < max; i++) {

            ctrl = this.control[i];

            RIPSAW.pen.line(this.map(ctrl.p[1].temp), this.map(ctrl.p[0].temp));
            RIPSAW.pen.line(this.map(ctrl.p[1].temp), this.map(ctrl.p[2].temp));

        }

    },


    /** Place control points. */
    placeControlPoints: function() {

        var i, max = this.control.length,
            j,
            ctrl;

        for (i = 0; i < max; i++) {

            ctrl = this.control[i];

            for (j = 0; j < 3; j += 1) {

                RIPSAW.pen.configure((j === 1) ? "primary control point" : "secondary control point");
                RIPSAW.pen.controlPoint(this.map(ctrl.p[j].temp), ctrl.hoverType === j);

            }

        }

    },


    /** Draw object. Manifest for all place[...] methods. */
    draw: function() {

        if (this.allow.draw) {

            RIPSAW.pen.configure("design outline");
            this.placeSpline();

            RIPSAW.pen.configure("design handle");
            this.placeControlHandles();

            RIPSAW.pen.configure("control point");
            this.placeControlPoints();

        }

        return this;

    },


    /** Returns deep copy. */
    clone: function() {

        var i,
            duplicate = new RIPSAW.BezierObject([], this.theta, this.p0.x, this.p0.y, this.scale),
            ctrl;

        for (i = 0, max = this.control.length; i < max; i += 1) {

            duplicate.control.push(this.control[i].clone());

        }

        return duplicate;

    },


    /** Updates hoverstates. */
    updateHoverState: function() {

        var i,
            max = this.control.length,
            ctrl;

        this.hoverIndex = -1;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];
            ctrl.hoverType = -1;

            for (j = 0; j <= 2; j += 1) {

                if (RIPSAW.mouse.hovers(this.map(ctrl.p[j].perm))) {

                    this.hoverIndex = i;
                    // if nodes 0 or 2 of the Bezier handle overlap with node 1, 1 should be selected
                    ctrl.hoverType = (ctrl.hoverType !== 1) ? j : 1;

                }

            }

        }

        return this;

    },


    /** Executed on mouse move. */
    mouseMove: function() {

        var globalDrag;

        if (this.allow.edit) {

            globalDrag = RIPSAW.mouse.getNormalizedDrag();

            if (!RIPSAW.mouse.isDragging) {

                this.updateHoverState();

            } else {

                // pan object
                if (this.hoverIndex === -1 && this.allow.pan) {

                    this.centroid.setDrag(globalDrag);

                }

                // modify control handles
                else if ((this.hoverIndex !== -1) && (/mode[1-3]/.test(RIPSAW.mode)) && this.allow.edit) {

                    this.control[this.hoverIndex].setDrag(this.getObjectDrag());
                    RIPSAW.isModified = true;

                }
            }

        }

        return this;

    },


    /** Executed on mouse up. */
    mouseUp: function() {

        if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].update();

        } else { // if screen is panned

            this.centroid.update();

        }

        return this;

    },


    /** Executed on mouse down. */
    mouseDown: function() {

        if (RIPSAW.mode === "smooth" && this.hoverIndex !== -1) {

            this.control[this.hoverIndex].smooth();

        }

        return this;

    },


    /**
     * Returns SVG path.
     * @returns {String}
     */
    toSVGPath: function() {

        var i, max = this.control.length,
            svgText,
            l = RIPSAW.rDim.l,
            ctrl1, ctrl2;

        svgText = "M" +
            ((this.control[0].p[1].perm.x + 0.5) * l).toFixed(2) + ',' +
            ((this.control[0].p[1].perm.y + 0.5) * l).toFixed(2);

        for (i = 0; i < max; i += 1) {

            ctrl1 = this.control[i];
            ctrl2 = (i === (max - 1)) ? this.control[0] : this.control[i + 1];

            svgText += 'C' +
                ((ctrl1.p[2].perm.x + 0.5) * l).toFixed(2) + ',' +
                ((ctrl1.p[2].perm.y + 0.5) * l).toFixed(2) + ',' +
                ((ctrl2.p[0].perm.x + 0.5) * l).toFixed(2) + ',' +
                ((ctrl2.p[0].perm.y + 0.5) * l).toFixed(2) + ',' +
                ((ctrl2.p[1].perm.x + 0.5) * l).toFixed(2) + ',' +
                ((ctrl2.p[1].perm.y + 0.5) * l).toFixed(2);

        }

        svgText += 'z';

        return svgText;

    },


    /**
     * Database-friendly export.
     * @returns {String}
     */
    toDB: function() {

        return this.toSVGPath();

    },


    /**
     * Reconstruct from database representation.
     * @returns {RIPSAW.Bezier2D} this
     */
    fromDB: function(geo) {

        this.control = new RIPSAW.BezierSVGPath(geo).toBezierHandles();

        return this;

    },


    /**
     * Returns full SVG file.
     * @returns {String}
     */
    toSVG: function() {

        var svgText = "";

        svgText = RIPSAW.textAssets.SVGHeader;

        svgText += '<path style="fill:none;stroke-width:4;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;" ';

        svgText += 'd="' + this.toSVGPath() + '">';

        svgText += RIPSAW.textAssets.SVGFooter;

        return svgText;

    },


    /** 
     * Returns Rhino PythonScript output.
     * @returns {String}
     */
    toRhinoPythonScript: function(curveName, curveNumber, isHorizontal) {

        var exportScript = "",
            pointArray,
            i, max, ctrl,
            l = RIPSAW.rDim.l,
            modifier = new RIPSAW.Vector(1.02, 1, 1 / RIPSAW.rDim.depthScale),
            getPointList = function(indexArray) {

                var i, max = indexArray.length,
                    pointList = "";

                for (i = 0; i < max; i += 1) {

                    pointList += "pts[" + (indexArray[i]) + "]";
                    if (i < max - 1) {
                        pointList += ",";
                    }

                }

                return pointList;

            };


        // header
        exportScript += '\n\trs.AddLayer("' + curveName + '")\n';
        exportScript += '\trs.CurrentLayer("' + curveName + '")\n';
        exportScript += "\n\tpts = []";
        exportScript += "\n\t" + curveName + "_crvs = []\n\n";


        // add points
        for (i = 0, max = this.control.length; i < max; i += 1) {

            ctrl = this.control[i];

            if (isHorizontal) {

                exportScript += ctrl.p[0].perm.clone().scale(l).toRhinoPythonScriptArray("pts");
                exportScript += ctrl.p[1].perm.clone().scale(l).toRhinoPythonScriptArray("pts");
                exportScript += ctrl.p[2].perm.clone().scale(l).toRhinoPythonScriptArray("pts");

            } else {

                exportScript += ctrl.p[0].perm.clone().swapYZ().scale(l).product(modifier).toRhinoPythonScriptArray("pts");
                exportScript += ctrl.p[1].perm.clone().swapYZ().scale(l).product(modifier).toRhinoPythonScriptArray("pts");
                exportScript += ctrl.p[2].perm.clone().swapYZ().scale(l).product(modifier).toRhinoPythonScriptArray("pts");

            }

        }

        // add curves
        for (i = 0, max = this.control.length; i < max; i += 1) {

            pointArray = "";

            if (i < this.control.length - 1) {

                pointArray = getPointList([3 * i + 1, 3 * i + 2, 3 * i + 3, 3 * i + 4]);
                exportScript += "\n\t" + curveName + "_crvs.append(" + "rs.AddCurve([" + pointArray + "]))";

            } else if (this.isClosed) {

                pointArray = getPointList([3 * i + 1, 3 * i + 2, 0, 1]);
                exportScript += "\n\t" + curveName + "_crvs.append(" + "rs.AddCurve([" + pointArray + "]))";

            }

        }

        exportScript += "\n\n\t" + curveName + "=rs.JoinCurves(" + curveName + "_crvs, True);\n\n";


        // add extrude paths
        exportScript += "\n\t" + curveName + "_extrudePath1 = rs.AddLine(" + "[0,0," + 0 + "]" + "," + ((isHorizontal) ? ("[0,0," + (-l / 2) + "]") : ("[0," + (-l / 2) + ",0]")) + ")";
        exportScript += "\n\t" + curveName + "_extrudePath2 = rs.AddLine(" + "[0,0," + 0 + "]" + "," + ((isHorizontal) ? ("[0,0," + l / 2 + "]") : ("[0," + l / 2 + ",0]")) + ")";

        // make and join extrusions
        exportScript += "\n\t" + curveName + "_srf1 = rs.ExtrudeCurve(" + curveName + "," + curveName + "_extrudePath1)";
        exportScript += "\n\t" + curveName + "_srf2 = rs.ExtrudeCurve(" + curveName + "," + curveName + "_extrudePath2)";

        exportScript += "\n\t" + curveName + "_srf = rs.JoinSurfaces([" + curveName + "_srf1," + curveName + "_srf2], True)";

        exportScript += "\n\n\n";

        return exportScript;

    }

};

RIPSAW.inheritPrototype(RIPSAW.MasterPiece, RIPSAW.Bezier2D);





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @constructor
 * @extends RIPSAW.MasterPiece
 */
RIPSAW.Bezier3D = function(path, depth) {

    // classical inheritance - prototype is inherited after subclass prototype is set
    RIPSAW.MasterPiece.call(this);

    /** @type {RIPSAW.Bezier2D} */
    this.plan = new RIPSAW.Bezier2D(path).normalize();

    /** @type {RIPSAW.Bezier2D[]} */
    this.side = [

        new RIPSAW.Bezier2D().createDepthProfile(+(depth || 0.2) / 2, 3),
        new RIPSAW.Bezier2D().createDepthProfile(-(depth || 0.2) / 2, 3)

    ];

    /** @type {RIPSAW.Camera} */
    this.camera = new RIPSAW.Camera();

    return this;

};

RIPSAW.Bezier3D.prototype = {

    set3DView: function() {

        this.plan.allow = this.side[0].allow = this.side[1].allow = {
            draw: false,
            edit: false
        };

        this.centroid = new RIPSAW.DragNode(0.5, 0.5);
        this.scale = 0.8;

        return this;

    },

    setAllView: function() {

        // set centroids
        this.centroid = new RIPSAW.DragNode(0.75, 0.4);
        this.plan.centroid = new RIPSAW.DragNode(0.25, 0.25);
        this.side[0].centroid = new RIPSAW.DragNode(0.25, 0.75);
        this.side[1].centroid = new RIPSAW.DragNode(0.25, 0.75);

        // set scale
        this.scale = 1;
        this.plan.scale = this.side[0].scale = this.side[1].scale = 0.55;

        // set 
        this.allow = this.plan.allow = this.side[0].allow = this.side[1].allow = {
            draw: true,
            edit: true
        };

        this.allow.rotate = false;

        return this;

    },

    setPlanView: function() {

        this.allow = this.side[0].allow = this.side[1].allow = {
            draw: false,
            edit: false
        };

        this.plan.centroid = new RIPSAW.DragNode(0.5, 0.5);
        this.plan.scale = 1;

    },

    get3DOutline: function(scaleFactor) {

        var i, j, max,

            profiles = [

                this.side[0].getSubdivision(RIPSAW.mesh.n2),
                this.side[1].getSubdivision(RIPSAW.mesh.n2)

            ],

            points = [this.plan.getSubdivision(RIPSAW.mesh.n2), this.plan.getSubdivision(RIPSAW.mesh.n2)],
            pt, interp;

        for (j = 0; j < 2; j += 1) {

            max = points[j].getPointCount();

            for (i = 0; i < max; i += 1) {

                pt = points[j].getPoint(i);

                interp = profiles[j].interpolateX(pt.x)[0];

                if (typeof interp !== "undefined") {

                    pt.z = interp.y / RIPSAW.rDim.depthScale;

                }

                pt.project(this.camera).scale(scaleFactor || 1);

            }

        }

        return points;

    },


    place3DIsoCurves: function(points, density) {

        var i,
            max = points[0].getPointCount();

        density = (typeof density !== "undefined") ? density : 5;

        RIPSAW.pen.configure("design iso");
        for (i = 0; i < max; i += density) {

            RIPSAW.pen.line(this.map(points[0].getPoint(i)), this.map(points[1].getPoint(i)));

        }

    },


    place3DOutline: function(points) {

        var i,
            max = points[0].getPointCount();

        for (i = 0; i < max - 1; i += 1) {

            RIPSAW.pen.line(this.map(points[0].getPoint(i)), this.map(points[0].getPoint(i + 1)));
            RIPSAW.pen.line(this.map(points[1].getPoint(i)), this.map(points[1].getPoint(i + 1)));

        }

    },


    draw3D: function() {

        var points;

        if (this.allow.draw) {

            points = this.get3DOutline();

            RIPSAW.pen.configure("design outline");
            this.place3DOutline(points);

            RIPSAW.pen.configure("design iso");
            this.place3DIsoCurves(points);

        }

    },


    draw: function(camera) {

        if (this.allow.draw) {

            this.draw3D();

        }

        this.plan.draw();
        this.side[0].draw();
        this.side[1].draw();

        return this;

    },

    mouseMove: function() {

        if (this.allow.rotate) {

            this.camera.mouseMove();

        }

        this.plan.mouseMove();
        this.side[0].mouseMove();
        this.side[1].mouseMove();

    },


    mouseUp: function() {

        if (this.allow.rotate) {
            this.camera.mouseUp();
        }

        this.plan.mouseUp();
        this.side[0].mouseUp();
        this.side[1].mouseUp();

    },


    mouseDown: function() {

        if (this.allow.rotate) {
            this.camera.mouseDown();
        }

        this.plan.mouseDown();
        this.side[0].mouseDown();
        this.side[1].mouseDown();

    },

    toSVG: function() {

        var result = "",
            points = this.get3DOutline(100),
            i, max = points[0].getPointCount();

        result += "\t" + points[0].toSVG() + "\n\t" + points[1].toSVG();

        result += "\n\t" + "<g>";

        for (i = 0; i < max; i += 5) {

            result += "\n\t\t" + new RIPSAW.Line(points[0].getPoint(i), points[1].getPoint(i)).toSVG();

        }

        result += "\n\t" + "</g>";

        return RIPSAW.textAssets.SVGHeader + "\n" + result + "\n" + RIPSAW.textAssets.SVGFooter;

    },

    toRhinoPythonScript: function() {

        var innerScript = (

            this.plan.toRhinoPythonScript("plan", 1, true) +
            this.side[0].toRhinoPythonScript("profileTop", 2.1, false) +
            this.side[1].toRhinoPythonScript("profileBottom", 2.2, false)

        );

        return RIPSAW.textAssets.rhinoPythonScriptHeader + innerScript + RIPSAW.textAssets.rhinoPythonScriptFooter;

    },

    /** 
     * Updates display and permission information by stage.
     */
    stageUpdate: function() {

        var currentState = this.stageManager[RIPSAW.stage.no];

        if (typeof currentState !== "undefined") {

            this.updateState(currentState.threeD);
            this.plan.updateState(currentState.plan);
            this.side[0].updateState(currentState.side);
            this.side[1].updateState(currentState.side);

        }

    }

};

RIPSAW.inheritPrototype(RIPSAW.MasterPiece, RIPSAW.Bezier3D);





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/** 
 * @class
 * @extends RIPSAW.MasterPiece
 * @param {number} n Number of segments.
 * @param {number} l Length of first segment.
 * @param {number} c Joint factor.
 * @param {number} [x0] See {@link RIPSAW.MasterPiece}.
 * @param {number} [y0] See {@link RIPSAW.MasterPiece}.
 * @param {number} [scale] See {@link RIPSAW.MasterPiece}.
 * @property {number} n Number of segments.
 * @property {number} l Length of first segment.
 * @property {number} c Joint factor.
 * @property {number} d Leg span - generated automatically.
 */
RIPSAW.Pantograph = function(n, l, c, x0, y0, scale) {

    // classical inheritance - prototype is inherited after subclass prototype is set
    RIPSAW.MasterPiece.call(this, x0, y0, scale);

    this.n = n;
    this.l = l;
    this.c = c;

    this.d = this.l * this.c;

    this.hoverIndex = -1;

    this.control = [];
    this.initControl();

    return this;

};


RIPSAW.Pantograph.prototype = {

    /**
     * Sets legspan.
     * @param {number} legSpan.
     * @returns {Object} this
     */
    setLegSpan: function(legSpan) {

        this.d = legSpan;

        return this;

    },


    initControl: function() {

        this.control = [

            new RIPSAW.DragNode(this.d / 2, 0, 0, 1, 0, 0),
            new RIPSAW.DragNode(0, -this.getSegmentHeight(0) * this.c, 0, 0, 1, 0)

        ];

        return this;

    },

    /**
     * Updates the position of the control points based on object geometry.
     * @returns {Object} this
     */
    updateControl: function() {

        this.control[0].temp.x = this.d / 2;
        this.control[1].temp.y = -this.getSegmentHeight(0) * this.c;

        return this;

    },


    /**
     * Updates the position of the control points based on object geometry.
     * @returns {Object} this
     */
    updateGeometry: function() {

        switch (this.hoverIndex) {

            case 0:
                this.d = this.control[0].temp.x * 2;
                break;

            case 1:
                this.l = Math.pow(Math.pow(this.control[1].temp.y, 2) + Math.pow(this.d / 2, 2), 0.5) / this.c;
                break;

        }

        return this;

    },

    /**
     * Gets height of a particular segment.
     * @param {number} segmentIndex The index of the segment.
     * @returns {number} height of the segment.
     */
    getSegmentHeight: function(segmentIndex) {

        var k = Math.pow((1 - this.c) / this.c, segmentIndex),
            l1 = this.l * k,
            d1 = this.d * k;

        return Math.pow(Math.pow(l1 * this.c, 2) - Math.pow(d1 / 2, 2), 0.5) / this.c;

    },


    getMembers: function(scaleFactor) {

        var l1 = this.l,
            d1 = this.d,
            hSegment,
            p1a, p2a, p1b, p2b,
            yStart = 0,
            members = [],
            scale = scaleFactor || 1;

        for (i = 0; i < this.n; i += 1) {

            hSegment = this.getSegmentHeight(i);

            p1a = new RIPSAW.Vector(-d1 / 2, -yStart).scale(scaleFactor);
            p1b = new RIPSAW.Vector(+d1 / 2 * (1 - this.c) / this.c, -(yStart + hSegment)).scale(scaleFactor);

            p2a = new RIPSAW.Vector(+d1 / 2, -yStart).scale(scaleFactor);
            p2b = new RIPSAW.Vector(-d1 / 2 * (1 - this.c) / this.c, -(yStart + hSegment)).scale(scaleFactor);

            members.push(new RIPSAW.Line(p1a, p1b));
            members.push(new RIPSAW.Line(p2a, p2b));

            d1 *= (1 - this.c) / this.c;
            l1 *= (1 - this.c) / this.c;

            yStart += hSegment;

        }

        return members;

    },

    /**
     * Places members on canvas.
     * @returns {Object} this.
     */
    placeMembers: function() {

        var members = this.getMembers(),
            i, max = members.length;

        for (i = 0; i < max; i += 1) {

            RIPSAW.pen.configure("design outline");
            RIPSAW.pen.line(this.map(members[i].p1), this.map(members[i].p2));

        }

        return this;

    },

    /**
     * Places control points on canvas.
     * @returns {Object} this.
     */
    placeControlPoints: function() {

        var i;

        for (i = 0; i < this.control.length; i += 1) {

            RIPSAW.pen.controlPoint(this.map(this.control[i].temp), this.hoverIndex === i);

        }

        return this;

    },

    /**
     * Draw object on canvas.
     */
    draw: function() {

        RIPSAW.pen.configure("design outline");
        this.placeMembers();

        RIPSAW.pen.configure("primary control point");
        this.placeControlPoints();

        return this;

    },

    /**
     * Determines whether legspan is valid.
     * @returns {boolean}.
     */
    hasValidLegSpan: function() {

        return (Math.abs(this.d) < this.l);

    },

    /**
     * Returns total height of the pantograph.
     * @returns {number} Total height.
     */
    getTotalHeight: function() {

        var totalHeight = 0;

        if (!this.hasValidLegSpan()) return totalHeight;

        for (i = 0; i < this.n; i += 1) {

            totalHeight += this.getSegmentHeight(i);

        }

        return totalHeight;

    },

    /**
     * Normalize object to a total height of 1.0.
     * @returns {Object} this
     */
    normalize: function() {

        var scaleRatio = 1 / this.getTotalHeight();

        this.l *= scaleRatio;
        this.d *= scaleRatio;

        this.updateControl();

        return this;

    },

    updateHoverState: function() {

        var i, max = this.control.length;

        this.hoverIndex = -1;

        for (i = 0; i < max; i += 1) {

            if (RIPSAW.mouse.hovers(this.map(this.control[i].perm))) {

                this.hoverIndex = i;

            }

        }

    },

    /**
     * MouseMove event handler: detects hover and update changes on control points.
     * @returns {Object} this
     */
    mouseMove: function() {

        if (!RIPSAW.mouse.isDragging) {

            this.updateHoverState();

        } else if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].setDrag(this.getObjectDrag());

            this.updateGeometry();
            this.updateControl();

        }

        return this;

    },

    /**
     * MouseUp event handler: permanently update changes on control points.
     * @returns {Object} this
     */
    mouseUp: function() {

        //this.normalize();

        if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].update();

        } else {



        }

        return this;

    },

    /**
     * MouseDown event handler.
     * @returns {Object} this
     */
    mouseDown: function() {

        return this;

    },


    toSVG: function() {

        var members = this.getMembers(100),
            i, max = members.length,
            innerScript = "";

        for (i = 0; i < max; i += 1) {

            innerScript += "\t" + members[i].toSVG() + "\n";

        }

        return RIPSAW.textAssets.SVGHeader + "\n" + innerScript + RIPSAW.textAssets.SVGFooter;

    }


};


RIPSAW.inheritPrototype(RIPSAW.MasterPiece, RIPSAW.Pantograph);





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


RIPSAW.CurvingPantograph = function(n, l, c1, c2, x0, y0, scale) {

    // classical inheritance - prototype is inherited after subclass prototype is set
    RIPSAW.MasterPiece.call(this, x0, y0, scale);

    this.n = n;
    this.l = l;
    this.c1 = c1;
    this.c2 = c2;

    this.d = this.l * this.c1;

    this.hoverIndex = -1;

    this.control = [];
    this.initControl();

    return this;

};


RIPSAW.CurvingPantograph.prototype = {

    /**
     * Sets legspan.
     * @param {number} legSpan.
     * @returns {Object} this
     */
    setLegSpan: function(legSpan) {

        this.d = legSpan;

        return this;

    },


    initControl: function() {

        this.control = [

            new RIPSAW.DragNode(this.d / 2, 0, 0, 1, 0, 0),

        ];

        return this;

    },

    /**
     * Updates the position of the control points based on object geometry.
     * @returns {Object} this
     */
    updateControl: function() {

        this.control[0].temp.x = this.d / 2;

        return this;

    },


    /**
     * Updates the position of the control points based on object geometry.
     * @returns {Object} this
     */
    updateGeometry: function() {

        this.d = this.control[0].temp.x * 2;

        return this;

    },

    /**
     * Gets height of a particular segment.
     * @param {number} segmentIndex The index of the segment.
     * @returns {number} height of the segment.
     */
    getSegmentHeight: function(segmentIndex) {

        var k = Math.pow((1 - this.c1) / this.c1, segmentIndex),
            l1 = this.l * k,
            d1 = this.d * k;

        return Math.pow(Math.pow(l1 * this.c1, 2) - Math.pow(d1 / 2, 2), 0.5) / this.c1;

    },


    getMembers: function(scaleFactor) {

        var members = [],
            hSegment,
            scale = scaleFactor || 1,
            p1 = new RIPSAW.Vector(+this.d / 2, 0),
            p2 = new RIPSAW.Vector(-this.d / 2, 0),
            p3, p4,
            pJoint,
            baseLine;

        for (i = 0; i < this.n; i += 1) {

            baseLine = new RIPSAW.Line(p1, p2);

            hSegment = this.getSegmentHeight(i);

            pJoint = baseLine.getMidPerpXY().scale(hSegment * this.c1).p2;

            p4 = new RIPSAW.Line(p1, pJoint).scale(1 / this.c1).p2;
            p3 = new RIPSAW.Line(p2, pJoint).scale(1 / this.c2).p2;

            members.push(new RIPSAW.Line(p1.clone().scale(scale), p4.clone().scale(scale)));
            members.push(new RIPSAW.Line(p2.clone().scale(scale), p3.clone().scale(scale)));

            p1 = p3;
            p2 = p4;

        }

        return members;

    },

    /**
     * Places members on canvas.
     * @returns {Object} this.
     */
    placeMembers: function() {

        var members = this.getMembers(),
            i, max = members.length;

        for (i = 0; i < max; i += 1) {

            RIPSAW.pen.configure("design outline");
            RIPSAW.pen.line(this.map(members[i].p1), this.map(members[i].p2));

        }

        return this;

    },

    /**
     * Places control points on canvas.
     * @returns {Object} this.
     */
    placeControlPoints: function() {

        var i;

        for (i = 0; i < this.control.length; i += 1) {

            RIPSAW.pen.controlPoint(this.map(this.control[i].temp), this.hoverIndex === i);

        }

        return this;

    },

    /**
     * Draw object on canvas.
     */
    draw: function() {

        RIPSAW.pen.configure("design outline");
        this.placeMembers();

        RIPSAW.pen.configure("primary control point");
        this.placeControlPoints();

        return this;

    },

    /**
     * Determines whether legspan is valid.
     * @returns {boolean}.
     */
    hasValidLegSpan: function() {

        return (Math.abs(this.d) < this.l);

    },

    /**
     * Returns total height of the pantograph.
     * @returns {number} Total height.
     */
    getTotalHeight: function() {

        var totalHeight = 0;

        if (!this.hasValidLegSpan()) return totalHeight;

        for (i = 0; i < this.n; i += 1) {

            totalHeight += this.getSegmentHeight(i);

        }

        return totalHeight;

    },

    /**
     * Normalize object to a total height of 1.0.
     * @returns {Object} this
     */
    normalize: function() {

        var scaleRatio = 1 / this.getTotalHeight();

        this.l *= scaleRatio;
        this.d *= scaleRatio;

        this.updateControl();

        return this;

    },

    updateHoverState: function() {

        var i, max = this.control.length;

        this.hoverIndex = -1;

        for (i = 0; i < max; i += 1) {

            if (RIPSAW.mouse.hovers(this.map(this.control[i].perm))) {

                this.hoverIndex = i;

            }

        }

    },

    /**
     * MouseMove event handler: detects hover and update changes on control points.
     * @returns {Object} this
     */
    mouseMove: function() {

        if (!RIPSAW.mouse.isDragging) {

            this.updateHoverState();

        } else if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].setDrag(this.getObjectDrag());

            this.updateGeometry();
            this.updateControl();

        }

        return this;

    },

    /**
     * MouseUp event handler: permanently update changes on control points.
     * @returns {Object} this
     */
    mouseUp: function() {

        //this.normalize();

        if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].update();

        } else {



        }

        return this;

    },

    /**
     * MouseDown event handler.
     * @returns {Object} this
     */
    mouseDown: function() {

        return this;

    },


    toSVG: function() {

        var members = this.getMembers(100),
            i, max = members.length,
            innerScript = "";

        for (i = 0; i < max; i += 1) {

            innerScript += "\t" + members[i].toSVG() + "\n";

        }

        return RIPSAW.textAssets.SVGHeader + "\n" + innerScript + RIPSAW.textAssets.SVGFooter;

    }


};

RIPSAW.inheritPrototype(RIPSAW.MasterPiece, RIPSAW.CurvingPantograph);





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * Intersection node of a Voronoi wavefront.
 * @param {Array} p - Array of intersection points.
 * @param {number} i - Index of first wavefront element.
 * @param {number} i - Index of second wavefront element.
 * @param {number}
 *
 */
RIPSAW.VoronoiIntersection = function(points, indeces) {

    this.points = points;

    this.waveFrontIndeces = indeces;

    return this;

};


RIPSAW.VoronoiIntersection.prototype = {


    toString: function() {

        var result = "";

        result += "{ " + this.points[0].toString();

        if (this.points[1]) {

            result += "; " + this.points[1].toString();

        }

        result += " } - " + this.waveFrontIndeces[0] + ', ' + this.waveFrontIndeces[1];

    },

    /**
     * Returns true if intersection is between the same two nodes.
     * @param {RIPSAW.VoronoiIntersection} vi - Intersection to match with.
     */
    matches: function(vi) {

        var wfi1 = this.waveFrontIndeces,
            wfi2 = vi.waveFrontIndeces;

        return (wfi1[0] === wfi2[0] && wfi1[1] === wfi2[1]);

    },


    /**
     * Returns whether intersection is identical to another intersection - both coordinates and endnodes.
     *
     */
    isNearIdenticalTo: function(vi) {

        var i, max = this.points.length;

        if (vi.points.length !== max) {

            return false;

        }

        for (i = 0; i < max; i += 1) {

            if (!this.points[i].isNearEqualTo(vi.points[i])) {

                return false;

            }

        }

        return this.matches(vi);

    }

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


RIPSAW.voronoiWave = function() {

    var w, min, max, period, sign, reachedEnd,
        that = {};

    min = 0.001;
    max = 0.8;
    w = min;
    sign = 0;
    period = 1.5;

    reachedEnd = false;

    /** Returns wavefron value. */
    that.get = function() {

        return w;

    };


    /** Returns wavefron value. */
    that.set = function(wArg) {

        w = wArg;

        return this;

    };


    /** Performs timestep change on wavefront. 
     * @param {boolean} [restart=false] - Should the step restart immediately.
     */
    that.step = function(restartArg) {

        var restart = (typeof restartArg === "undefined") ? false : restartArg;

        w += (max - min) * sign * RIPSAW.refreshInterval / (period * 1000);

        if (w < min) {

            sign = -1;

        }

        if (w > max) {

            sign = restart ? 1 : 0;

            w = min;
            reachedEnd = true;

        }

        return this;

    };


    /** Resets wavefront to default. */
    that.reset = function() {

        w = min;

        return this;

    };


    that.start = function() {

        sign = +1;

        return this;

    };


    that.reachedEnd = function() {

        return reachedEnd;

    };


    that.restart = function() {

        w = min;
        sign = +1;

        return this;

    };


    /** Sets maximum wavefront length. */
    that.setMax = function(maxArg) {

        max = maxArg;

        return this;

    };


    /** Sets minimum wavefront length. */
    that.setMin = function(minArg) {

        min = minArg;

        return this;

    };


    /** Sets period. */
    that.setPeriod = function(periodArg) {

        period = periodArg;

        return this;

    };

    return that;

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


RIPSAW.voronoiWaveFront = function(controlNodesArg) {

    var list = [],
        n = 4, // number of wavefront lines per node
        that = {},
        controlNodes = controlNodesArg;

    /** 
     * Add wave element to list.
     * @param {RIPSAW.Line} line
     * @returns {Object} this
     */
    that.add = function(line) {

        list.push(line);

        return this;

    };


    /**
     * Returns a deep copy of the list.
     *
     */
    that.getList = function() {

        var i, max = list.length,
            listCopy = [];

        for (i = 0; i < max; i += 1) {

            listCopy.push(list[i].clone());

        }

        return listCopy;

    };


    /** 
     * Clears wavefront list.
     * @returns {Object} this
     */
    that.clear = function() {

        list = [];

        return this;

    };


    /** 
     * Builds square wavefront around a list of points, counterclockwise around each.
     * @param {Array} points - Array of points.
     * @param {number} waveSize
     * @returns {Object} this
     */
    that.build = function(waveSize) {

        var i, max = controlNodes.length,
            p1, p2, p3, p4, pt;

        list = [];

        for (i = 0; i < max; i += 1) {

            pt = controlNodes[i].temp;

            p1 = pt.clone().add(new RIPSAW.Vector(+waveSize, 0));
            p2 = pt.clone().add(new RIPSAW.Vector(0, +waveSize));
            p3 = pt.clone().add(new RIPSAW.Vector(-waveSize, 0));
            p4 = pt.clone().add(new RIPSAW.Vector(0, -waveSize));

            list.push(new RIPSAW.Line(p1, p2));
            list.push(new RIPSAW.Line(p2, p3));
            list.push(new RIPSAW.Line(p3, p4));
            list.push(new RIPSAW.Line(p4, p1));

        }

        return this;

    };


    /**
     * Intersects wavefront.
     * @returns {Array} nodes - Intersection nodes.
     */
    that.getIntersections = function() {

        var i, j,
            wi, wj,
            isect,
            nodes = [],
            node,
            max = list.length;

        for (i = 0; i < max; i += 1) {

            wi = list[i];

            for (j = i + 1; j < max; j += 1) {

                if (Math.floor(i / n) !== Math.floor(j / n)) {

                    wj = list[j];

                    isect = wi.intersectXY(wj, 4e-3);

                    if (isect.type === "inside" || isect.type === "overlap") {

                        node = new RIPSAW.VoronoiIntersection(isect.points, [i, j]);

                        nodes.push(node);

                    }

                }

            }

        }

        return nodes;

    };


    /**
     * Checks if an intersection is at the same Manhattan distance between at least two control nodes.
     * @param {RIPSAW.Vector} pt
     * @returns {boolean}
     */
    that.isControllingIntersection = function(pt) {

        var i, max = controlNodes.length,
            minCount, minDistance,
            ctrl;

        minCount = 0;
        minDistance = 10000;

        for (i = 0; i < max; i += 1) {

            ctrl = controlNodes[i].temp;

            distance = pt.getManhattanDistanceTo(ctrl);

            if (RIPSAW.areNearEqual(distance, minDistance, 4e-3 * 1.4)) {

                minCount += 1;

            } else if (distance < minDistance) {

                minDistance = distance;

                minCount = 1;

            }


        }

        return (minCount >= 2);

    };


    /**
     * Intersects wavefront, only including intersection nodes within the range of a control point.
     * !!ISSUE!!: near equal tolerance does not filter overlap links correctly.
     * @returns {Array} nodes - Intersection nodes.
     */
    that.getSimpleIntersections = function() {

        var i, j,
            nodes = this.getIntersections(),
            max = nodes.length,
            node,
            pts,
            newNodes = [];

        for (i = 0; i < max; i += 1) {

            node = nodes[i];

            pts = node.points;

            if (this.isControllingIntersection(pts[0]) ||
                (pts[1] && this.isControllingIntersection(pts[1]))
            ) {

                newNodes.push(node);

            }

        }

        return newNodes;

    };


    return that;

};





/*     ~~~~~     */
/* ~~~~~~~~~~~~~ */
/*   ~~~~~~~~~   */


/**
 * @constructor
 * @extends RIPSAW.masterPiece
 *
 */
RIPSAW.Voronoi = function() {

    // classical inheritance - prototype is inherited after subclass prototype is set
    RIPSAW.MasterPiece.call(this);

    this.nodes = [];

    this.links = [];

    // wavefront expansion, Robert Goerke + Alexander Wolff article, Uni Karlsruhe
    this.wave = RIPSAW.voronoiWave();

    this.waveFront = RIPSAW.voronoiWaveFront(this.control);

    return this;

};


RIPSAW.Voronoi.prototype = {

    /**
     * Adds control node.
     * @param {RIPSAW.Vector} pt
     * @returns {RIPSAW.Voronoi} this
     */
    addControlPoint: function(pt) {

        this.control.push(new RIPSAW.DragNode(pt.x || 0, pt.y || 0));

        return this;

    },


    /**
     * Creates rectangular control point grid. Does not delete previous control points.
     * @param {number} a - Width.
     * @param {number} b - Height.
     * @param {number} na - Number of points along x axis.
     * @param {number} nb - Number of points along y axis.
     */
    createRectangularGrid: function(a, b, na, nb) {

        var i, j, max;

        for (i = 0; i < na; i += 1) {

            for (j = 0; j < nb; j += 1) {

                this.addControlPoint(new RIPSAW.Vector(i * a / (na - 1), j * b / (nb - 1), 0));

            }

        }

        return this;

    },


    /**
     * Creates random grid within (-0.5, -0.5) - (+0.5, +0.5) square.
     * @param {number} n - Number of control points.
     * @returns {RIPSAW.Voronoi} this
     */
    createIrregularGrid: function(n) {

        var i;

        for (i = 0; i < n; i += 1) {

            this.addControlPoint({

                x: Math.random() - 0.5,
                y: Math.random() - 0.5

            });

        }

        return this;

    },


    /**
     * Returns bounding rectangle in a {min: , max: } object format.
     * @returns {Object}
     */
    getBoundingRectangle: function() {

        var maxX = -5000,
            maxY = -5000,
            minX = +5000,
            minY = +5000, // max/min coordinates for normalization
            i, max = this.control.length,
            ctrl;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i].temp;

            maxX = Math.max(maxX, ctrl.x);
            minX = Math.min(minX, ctrl.x);

            maxY = Math.max(maxY, ctrl.y);
            minY = Math.min(minY, ctrl.y);

        }

        return {

            min: new RIPSAW.Vector(minX, minY),
            max: new RIPSAW.Vector(maxX, maxY)

        };

    },


    /**
     * Returns geometric centroid of control nodes.
     * @returns {RIPSAW.Vector}
     */
    getCentroid: function() {

        var br = this.getBoundingRectangle();

        return new RIPSAW.Vector((br.max.x + br.min.x) / 2, (br.max.y + br.min.y) / 2);

    },


    /** 
     * Returns maximum flat dimension in x and y directions.
     * @returns {number} maxDim
     */
    getMaxDim: function() {

        var br = this.getBoundingRectangle();

        return Math.max(br.max.x - br.min.x, br.max.y - br.min.y);

    },


    /** 
     * Moves all control points.
     * @param {RIPSAW.Vector} displacement
     * @returns {RIPSAW.Voronoi} this
     */
    moveGeometry: function(displacement) {

        var i, max = this.control.length,
            ctrl;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];

            ctrl.temp.add(displacement);
            ctrl.update();

        }

        return this;

    },


    /** 
     * Scales all control points with respect to the origin.
     * @returns {RIPSAW.Voronoi} this
     */
    scaleGeometry: function(scaleFactor) {

        var i, max = this.control.length,
            ctrl,
            fact = scaleFactor || 1;

        for (i = 0; i < max; i += 1) {

            ctrl = this.control[i];

            ctrl.temp.scale(fact);
            ctrl.update();

        }

        return this;

    },


    /**
     * Normalizes handles so that they fit in the (-0.5, -0.5) -> (+0.5, +0.5) rectangle.
     * @param {number} [scale=1.0] Additional scale factor.
     */
    normalize: function(scale) {

        var centroid, scaleFactor;

        scale = scale || 1;

        centroid = this.getCentroid();
        scaleFactor = 1 / this.getMaxDim() * scale;

        this.moveGeometry(centroid.scale(-1)).scaleGeometry(scaleFactor);

        return this;

    },


    /**
     * Performs timestep operations on geometry.
     *
     */
    step: function() {

        var i, maxi,
            j, maxj,
            node, link,
            win, wil,
            foundMatch = false;

        this.wave.step();
        this.waveFront.build(this.wave.get());
        this.nodes = this.waveFront.getSimpleIntersections();

        // loop over new nodes
        for (i = 0, maxi = this.nodes.length; i < maxi; i += 1) {

            node = this.nodes[i];

            win = node.waveFrontIndeces;

            foundMatch = false;

            // loop over existing links
            for (j = 0, maxj = this.links.length; j < maxj; j += 1) {

                link = this.links[j];

                wil = link.waveFrontIndeces;

                // for regular links that do not result from overlapping wavefronts
                //     the second link node is updated
                if (win[0] === wil[0] && win[1] === wil[1]) {

                    if (!link.isOverlapLink) {

                        link.p2 = node.points[0];

                    }

                    foundMatch = true;

                }

            }

            // if no match is found, link is added to the list
            if (!foundMatch) {

                if (node.points.length === 1) {

                    this.links.push({

                        p1: node.points[0], // start point only, endpoint inserted in next match
                        isOverlapLink: false,
                        waveFrontIndeces: node.waveFrontIndeces

                    });

                } else if (node.points.length === 2) {

                    this.links.push({

                        p1: node.points[0],
                        p2: node.points[1],
                        isOverlapLink: true,
                        waveFrontIndeces: node.waveFrontIndeces

                    });

                }

            }

        }

        return this;

    },


    /**
     * Places wavefront.
     * @returns {RIPSAW.Voronoi} this
     */
    placeWaveFront: function() {

        var i, l,
            waveFront = this.waveFront.getList(),
            max = waveFront.length;

        for (i = 0; i < max; i += 1) {

            l = waveFront[i];
            RIPSAW.pen.line(this.map(l.p1), this.map(l.p2));

        }

        return this;

    },


    /**
     * Places links.
     * @returns {RIPSAW.Voronoi} this
     */
    placeLinks: function() {

        var l, i, max = this.links.length,
            p1, p2;

        for (i = 0; i < max; i += 1) {

            l = this.links[i];

            if (l.p2) {

                RIPSAW.pen.line(this.map(l.p1), this.map(l.p2));

                RIPSAW.pen.controlPoint(this.map(l.p1));
                RIPSAW.pen.controlPoint(this.map(l.p2));

            }

        }

        return this;

    },


    /**
     * Places nodes.
     * @returns {RIPSAW.Voronoi} this
     */
    placeNodes: function() {

        var i, max = this.nodes.length;

        for (i = 0, max = this.nodes.length; i < max; i += 1) {

            RIPSAW.pen.controlPoint(this.map(this.nodes[i].points[0]));

        }

        return this;

    },


    /** 
     * Drawing manifest file.
     * @returns {RIPSAW.Voronoi} this
     */
    draw: function(relControlPointWidth) {

        var i, max,
            r = (relControlPointWidth || 2.4);

        this.step();

        RIPSAW.pen.configure("primary control point");

        for (i = 0, max = this.control.length; i < max; i += 1) {

            RIPSAW.pen.controlPoint(this.map(this.control[i].temp), (this.hoverIndex === i));

        }

        RIPSAW.pen.configure("design thin");
        this.placeWaveFront();

        RIPSAW.pen.configure("design iso");
        this.placeLinks();

        RIPSAW.pen.configure("point");
        this.placeNodes();

        return this;

    },


    mouseUp: function() {

        if (this.hoverIndex !== -1) {

            this.control[this.hoverIndex].update();

        } else {

            //this.centroid.update();

        }

        return this;

    },


    mouseDown: function() {

        return this;

    },


    updateHoverState: function() {

        var i,
            max = this.control.length;

        this.hoverIndex = -1;

        for (i = 0; i < max; i += 1) {

            if (RIPSAW.mouse.hovers(this.map(this.control[i].perm))) {

                this.hoverIndex = i;

            }

        }

        return this;

    },


    mouseMove: function() {

        var ctrl,
            globalDrag = RIPSAW.mouse.getNormalizedDrag();

        if (RIPSAW.mouse.isDragging) {

            if (this.hoverIndex !== -1) {

                this.control[this.hoverIndex].setDrag(this.getObjectDrag());

            } else {

                //this.p0T = this.p0.copy().add(globalDrag);

            }

        } else {

            this.updateHoverState();

        }

        return this;

    },


    mouseDownRight: function() {

        console.log(this.toRhinoPythonScript());

        this.links = [];

        this.wave.reset().start();

        return this;

    },


    toSVGPath: function(factorArg) {

        var link, result = "",
            i, max = this.links.length,
            factor = factorArg || 100;

        for (i = 0; i < max; i += 1) {

            link = this.links[i];

            if (link.p2) {

                result += new RIPSAW.Line(link.p1.clone().scale(factor), link.p2.clone().scale(factor)).toSVG() + "\n";

            }

        }

        return result;

    },


    toSVG: function() {

        return RIPSAW.textAssets.SVGHeader + this.toSVGPath() + RIPSAW.textAssets.SVGFooter;

    },

    toRhinoPythonScript: function(factorArg) {

        var link, result = "",
            i, max,
            factor = factorArg || 100;

        result = RIPSAW.textAssets.rhinoPythonScriptHeader;


        for (i = 0, max = this.control.length; i < max; i += 1) {

            result += "\trs.AddPoint(" + this.control[i].temp.clone().scale(factor).toRhinoPythonScript() + ")\n";

        }

        for (i = 0, max = this.links.length; i < max; i += 1) {

            link = this.links[i];

            if (link.p2) {

                result += "\t" + new RIPSAW.Line(link.p1.clone().scale(factor), link.p2.clone().scale(factor)).toRhinoPythonScript() + "\n";

            }

        }

        result += RIPSAW.textAssets.rhinoPythonScriptFooter;

        return result;

    }

};

RIPSAW.inheritPrototype(RIPSAW.MasterPiece, RIPSAW.Voronoi);
